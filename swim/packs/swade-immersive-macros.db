{"_id":"49TiCaAgArpHsAhz","name":"SWIM: Ammo usage","permission":{"default":0,"wpWSO3unowg8siJN":3},"type":"script","flags":{"combat-utility-belt":{"macroTrigger":""},"furnace":{"runAsGM":false},"core":{"sourceId":"Macro.mMb87BLxl6JfQXQ1"}},"scope":"global","command":"checkWeapon();\n\nasync function checkWeapon() {\n    //Don't execute the macro on a reroll by checking if the old_rolls is empty:\n    if (message.data.flags['betterrolls-swade2'].render_data.trait_roll.old_rolls.length >= 1) { return; }\n    //Check whether or not the weapon is suitable for the shooting macro\n    if (\n        (item.type === \"weapon\" &&\n            //i.data.data.range !== \"0\" && i.data.data.range !== \"\" &&\n            item.data.data.ammo.trim() !== \"\" &&\n            item.data.data.quantity > 0) ||\n        (item.type === \"weapon\" &&\n            //i.data.data.range !== \"0\" && i.data.data.range !== \"\" &&\n            item.data.data.additionalStats.isConsumable &&\n            item.data.data.additionalStats.isConsumable.value === true &&\n            item.data.data.quantity > 0)\n    ) { shoot(); }\n    else { return; }\n}\n\nasync function shoot() {\n    //let [shots, weapon, ammo, sil] = getValues(html);\n    let item_weapon = item;\n    //Stop if the item is not a weapon:\n    if (item_weapon.type != \"weapon\") { return; }\n    //Get ammo loaded in the weapon and amount of shots provided by BR2 as well as a silenced state:\n    let item_ammo;\n    if (item_weapon.data.data.additionalStats.loadedAmmo) {\n        let loaded_ammo = item_weapon.data.data.additionalStats.loadedAmmo.value;\n        item_ammo = actor.items.getName(`${loaded_ammo}`);\n    }\n    //Setting the amount of shots based on RoF:\n    let traitDice = message.data.flags['betterrolls-swade2'].render_data.trait_roll.dice;\n    //console.log(traitDice);\n    //console.log(message.data.flags['betterrolls-swade2'].render_data);\n    let rate_of_fire = traitDice.length;\n    if (actor.data.data.wildcard === true) { rate_of_fire = rate_of_fire - 1; }\n    //console.log(rate_of_fire);\n    let shots;\n    if (rate_of_fire === 1) { shots = 1; }\n    if (rate_of_fire === 2) { shots = 5; }\n    if (rate_of_fire === 3) { shots = 10; }\n    if (rate_of_fire === 4) { shots = 20; }\n    if (rate_of_fire === 5) { shots = 40; }\n    if (rate_of_fire === 6) { shots = 50; }\n\n    let sil = false;\n    if (item_weapon.data.data.additionalStats.silenced && item_weapon.data.data.additionalStats.silenced.value === true) {\n        sil = true;\n    }\n    // Getting the sfx from the weapon provided by BR2:\n    let sfx_shot;\n    let sfx_silenced;\n    let sfx_shot_auto;\n    let sfx_silenced_auto;\n    let sfx_empty;\n    if (item_weapon.data.data.additionalStats.sfx) {\n        let sfx = item_weapon.data.data.additionalStats.sfx.value.split(`|`);\n        sfx_shot = sfx[1];\n        sfx_silenced = sfx[3];\n        sfx_shot_auto = sfx[2];\n        sfx_silenced_auto = sfx[4];\n        sfx_empty = sfx[5];\n    }\n    // Getting Weapon and loaded ammo\n    const weaponIMG = item_weapon.data.img;\n    let currentAmmo\n    if (item_weapon.data.data.additionalStats.loadedAmmo) {\n        currentAmmo = item_weapon.data.data.additionalStats.loadedAmmo.value;\n    }\n\n    // Calculating shots to expend\n    const currentCharges = parseInt(item_weapon.data.data.currentShots);\n    const newCharges = currentCharges - shots;\n    if (item_weapon.data.data.additionalStats.isConsumable && item_weapon.data.data.additionalStats.isConsumable.value === true) {\n        const currentQuantity = parseInt(item_weapon.data.data.quantity);\n        if (currentQuantity <= 0) {\n            return ui.notifications.error(`You don't have a ${item_weapon.name} left.`);\n        }\n        const newQuantity = currentQuantity - shots;\n        const updates = [\n            { _id: item_weapon.id, \"data.quantity\": `${newQuantity}` },\n        ];\n        // Updating the consumable weapon\n        await actor.updateOwnedItem(updates);\n        // Deleting the consumable weapon if it was the last\n        if (newQuantity <= 0) {\n            item_weapon.delete();\n        }\n        // Creating the Chat message\n        ChatMessage.create({\n            speaker: {\n                alias: actor.name\n            },\n            content: `<img src=\"${weaponIMG}\" alt=\"\" width=\"25\" height=\"25\" /> ${actor.name} uses ${shots} ${item_weapon.name}(s) and has ${newQuantity} left.`\n        })\n        // Play sound effects\n        if (sfx_shot) {\n            AudioHelper.play({ src: `${sfx_shot}` }, true);\n        }\n    }\n    // Check if enough bullets are in the weapon to fire the given amount of shots if this is not a consumable weapon.\n    else if (currentCharges < shots) {\n        ui.notifications.error(\"You have insufficient ammunition.\");\n        if (sfx_empty && currentCharges === 0) {\n            AudioHelper.play({ src: `${sfx_empty}` }, true);\n        }\n        return;\n    }\n    else {\n        const updates = [\n            { _id: item_weapon.id, \"data.currentShots\": `${newCharges}` },\n        ];\n        // Updating the Weapon\n        actor.updateOwnedItem(updates);\n        // Creating the Chat message\n        if (!currentAmmo) {\n            ChatMessage.create({\n                speaker: {\n                    alias: actor.name\n                },\n                content: `<img src=\"${weaponIMG}\" alt=\"\" width=\"25\" height=\"25\" /> ${actor.name} fires <b>${shots} round(s)</b> from a ${item_weapon.name} and has <b>${newCharges} left</b>.`\n            })\n        } else {\n            ChatMessage.create({\n                speaker: {\n                    alias: actor.name\n                },\n                content: `<img src=\"${weaponIMG}\" alt=\"\" width=\"25\" height=\"25\" /> ${actor.name} fires <b>${shots} ${currentAmmo} round(s)</b> from a ${item_weapon.name} and has <b>${newCharges} left</b>.`\n            })\n        }\n        // Play sound effects\n        if (sil === true && sfx_silenced) {\n            if (shots > 4 && sfx_silenced_auto) {\n                AudioHelper.play({ src: `${sfx_silenced_auto}` }, true);\n            }\n            else {\n                AudioHelper.play({ src: `${sfx_silenced}` }, true);\n            }\n        }\n        else {\n            if (shots > 4 && sfx_shot_auto) {\n                AudioHelper.play({ src: `${sfx_shot_auto}` }, true);\n            }\n            else {\n                AudioHelper.play({ src: `${sfx_shot}` }, true);\n            }\n        }\n    }\n    //V. 1.0.0 by SalieriC#8263 with help from javierrivera#4813.\n}","author":"wpWSO3unowg8siJN","img":"icons/weapons/crossbows/crossbow-long-brown.webp","actorIds":[]}
{"_id":"B5E9BD9yruj5P6Fn","name":"Fear Table","permission":{"default":0,"wpWSO3unowg8siJN":3},"type":"script","flags":{"combat-utility-belt":{"macroTrigger":""},"core":{"sourceId":"Macro.8yUqe3V9NkdWCbrV"}},"scope":"global","command":"const dialog = new Dialog({\n    title: 'Fear',\n    content: '<form class=\"fearTable\"><div class=\"form-group\"><label>Fear Modifier</label><input type=\"number\" name=\"fearModifier\" /></div></form>',\n    default: 'roll',\n    buttons: {\n        roll: {\n            label: 'Roll',\n            callback: (html) => {\n                let modifier = html.find('.fearTable input[name=\"fearModifier\"]')[0].value;\n\n                if (modifier === '') {\n                    modifier = 0;\n                }\n                \n                modifier = parseInt(modifier);\n                const roll = new Roll('1d20 + @mod', { mod: modifier });\n                let fearTableName = game.settings.get(\n                    'swim', 'fearTable');\n                    if (fearTableName) {\n                        game.tables.getName(`${fearTableName}`).draw({ roll });\n                    }\n                    else {\n                        ui.notifications.error(\"Please set a Fear table name in the SWIM settings.\");\n                        return;\n                    }\n                let fearSFX = game.settings.get(\n                    'swim', 'fearSFX');\n                if (fearSFX) {\n                    AudioHelper.play({ src: `${fearSFX}` }, true);\n                }                \n            }\n        }\n    },\n    render: ([dialogContent]) => {\n        dialogContent.querySelector(`input[name=\"fearModifier\"`).focus();\n    },\n    default: \"roll\"\n    // v.1.1.1\n});\ndialog.render(true);","author":"wpWSO3unowg8siJN","img":"icons/commodities/biological/eye-blue-gold.webp","actorIds":[]}
{"_id":"BUyr1htAVTa91SYy","name":"Token Vision","permission":{"default":0,"wpWSO3unowg8siJN":3},"type":"script","flags":{"combat-utility-belt":{"macroTrigger":""},"core":{"sourceId":"Macro.e3HFjRo6KaIDsfCR"}},"scope":"global","command":"// Open a dialog for quickly changing token vision parameters of the controlled tokens.\n// This macro was originally written by @Sky#9453\n// https://github.com/Sky-Captain-13/foundry\n// SWADE (this) version by SalieriC\n\n// Since return only works in functions, the sole purpose of the main() function is to stop the macro from executing if no token is selected.\nmain();\n\nfunction main() {\n  // Checking if at least one token is defined.\n  if (canvas.tokens.controlled.length === 0) {\n    ui.notifications.error(\"Please select a token first\");\n    return;\n  }\n  // Add Vision Type only if the Game Master is using the Macro\n  let dialogue_content;\n  if (game.user.isGM) {\n    dialogue_content = `\n    <form>\n      <div class=\"form-group\">\n        <label>Light Source:</label>\n        <select id=\"light-source\" name=\"light-source\">\n          <option value=\"nochange\">No Change</option>\n          <option value=\"none\">None</option>\n          <option value=\"candle\">Candle</option>\n          <option value=\"lamp\">Lantern</option>\n          <option value=\"bullseye\">Lantern (Bullseye)</option>\n          <option value=\"torch\">Torch</option>\n          <option value=\"flLight\">Flashlight</option>\n        </select>\n      </div>\n      <div class=\"form-group\">\n        <label>Vision Type:</label>\n        <select id=\"vision-type\" name=\"vision-type\">\n          <option value=\"nochange\">No Change</option>\n          <option value=\"pDark\">Pitch Darkness (0\")</option>\n          <option value=\"dark\">Dark (10\")</option>\n          <option value=\"dim\">Dim</option>\n          <option value=\"lowLiVis\">Low Light Vision</option>\n          <option value=\"infrVis\">Infravision</option>\n          <option value=\"fullNiVis\">Full Night Vision</option>\n        </select>\n      </div>\n    </form>\n`;\n  } else {\n    dialogue_content = `\n    <form>\n      <div class=\"form-group\">\n        <label>Light Source:</label>\n        <select id=\"light-source\" name=\"light-source\">\n          <option value=\"nochange\">No Change</option>\n          <option value=\"none\">None</option>\n          <option value=\"candle\">Candle</option>\n          <option value=\"lamp\">Lantern</option>\n          <option value=\"bullseye\">Lantern (Bullseye)</option>\n          <option value=\"torch\">Torch</option>\n          <option value=\"flLight\">Flashlight</option>\n        </select>\n      </div>\n    `;\n  }\n\n  let applyChanges = false;\n  new Dialog({\n    title: `Token Vision Configuration`,\n    content: dialogue_content,\n    buttons: {\n      yes: {\n        icon: \"<i class='fas fa-check'></i>\",\n        label: `Apply Changes`,\n        callback: () => applyChanges = true\n      },\n      no: {\n        icon: \"<i class='fas fa-times'></i>\",\n        label: `Cancel Changes`\n      },\n    },\n    default: \"yes\",\n    close: html => {\n      if (applyChanges) {\n        for (let token of canvas.tokens.controlled) {\n          let visionType;\n          let lightSource = html.find('[name=\"light-source\"]')[0].value || \"none\";\n          let dimSight = 0;\n          let brightSight = 0;\n          let dimLight = 0;\n          let brightLight = 0;\n          let lightAngle = 360;\n          let lockRotation = token.data.lockRotation;\n          // Get Vision Type Values\n          if (game.user.isGM){\n            visionType = html.find('[name=\"vision-type\"]')[0].value || \"none\";\n          switch (visionType) {\n            case \"pDark\":\n              dimSight = 0;\n              brightSight = 0;\n              break;\n            case \"dark\":\n              dimSight = 10;\n              brightSight = 0;\n              break;\n            case \"dim\":\n              dimSight = 1000;\n              brightSight = 10;\n              break;\n            case \"lowLiVis\":\n              dimSight = 1000;\n              brightSight = 0;\n              break;\n            case \"infrVis\":\n              dimSight = 1000;\n              brightSight = 0;\n              break;\n            case \"fullNiVis\":\n              dimSight = 0;\n              brightSight = 1000;\n              break;\n            case \"nochange\":\n            default:\n              dimSight = token.data.dimSight;\n              brightSight = token.data.brightSight;\n          }\n          // Get Light Source Values\n          switch (lightSource) {\n            case \"none\":\n              dimLight = 0;\n              brightLight = 0;\n              break;\n            case \"candle\":\n              dimLight = 0;\n              brightLight = 2;\n              break;\n            case \"lamp\":\n              dimLight = 0;\n              brightLight = 4;\n              break;\n            case \"bullseye\":\n              dimLight = 0;\n              brightLight = 4;\n              lockRotation = true;\n              lightAngle = 52.5;\n              break;\n            case \"torch\":\n              dimLight = 0;\n              brightLight = 4;\n              break;\n            case \"flLight\":\n              dimLight = 0;\n              brightLight = 10;\n              lockRotation = true;\n              lightAngle = 52.5;\n              break;\n            case \"nochange\":\n            default:\n              dimLight = token.data.dimLight;\n              brightLight = token.data.brightLight;\n              lightAngle = token.data.lightAngle;\n              lockRotation = token.data.lockRotation;\n          }\n          // Update Token\n          console.log(token);\n          token.update({\n            vision: true,\n            dimSight: dimSight,\n            brightSight: brightSight,\n            dimLight: dimLight,\n            brightLight: brightLight,\n            lightAngle: lightAngle,\n            lockRotation: lockRotation\n          });\n        }\n        else {\n          // Get Light Source Values\n          switch (lightSource) {\n            case \"none\":\n              dimLight = 0;\n              brightLight = 0;\n              break;\n            case \"candle\":\n              dimLight = 0;\n              brightLight = 2;\n              break;\n            case \"lamp\":\n              dimLight = 0;\n              brightLight = 4;\n              break;\n            case \"bullseye\":\n              dimLight = 0;\n              brightLight = 4;\n              lockRotation = true;\n              lightAngle = 52.5;\n              break;\n            case \"torch\":\n              dimLight = 0;\n              brightLight = 4;\n              break;\n            case \"flLight\":\n              dimLight = 0;\n              brightLight = 10;\n              lockRotation = true;\n              lightAngle = 52.5;\n              break;\n            case \"nochange\":\n            default:\n              dimLight = token.data.dimLight;\n              brightLight = token.data.brightLight;\n              lightAngle = token.data.lightAngle;\n              lockRotation = token.data.lockRotation;\n          }\n          // Update Token\n          console.log(token);\n          token.update({\n            vision: true,\n            dimLight: dimLight,\n            brightLight: brightLight,\n            lightAngle: lightAngle,\n            lockRotation: lockRotation\n          });\n        }\n        }\n      }\n    }\n  }).render(true);\n  // v.2.0.4\n}","author":"wpWSO3unowg8siJN","img":"icons/sundries/lights/torch-black.webp","actorIds":[]}
{"_id":"C7YFvoIVgVKtDUiO","name":"Raise Calculator (Dynamic)","permission":{"default":0,"wpWSO3unowg8siJN":3},"type":"script","flags":{"combat-utility-belt":{"macroTrigger":""},"furnace":{"runAsGM":false},"core":{"sourceId":"Macro.onkkfY2zBddVpiLr"}},"scope":"global","command":"let text = `<img style=\"border: 0;\" src=\"modules/swim/assets/icons/misc/raise_black.svg\" alt=\"\" width=\"25\" height=\"25\" /> Your Raises will show here once you leave the Result field.`;\n\nnew Dialog({\n    title: 'Raise Calculator',\n    content: `\n        <form>\n        <div class=\"form-group\">\n        <label><img src=\"modules/swim/assets/icons/misc/bullseye.svg\" alt=\"\" width=\"25\" height=\"25\" style=\"border: 0;\" /> <b>Target Number:</b></label> \n        <input name=\"target\" placeholder=\"0\" type=\"text\" autofocus onClick=\"this.select();\"/>\n       </div>\n       <div class=\"form-group\">\n        <label><img src=\"modules/swim/assets/icons/misc/rolling-dices.svg\" alt=\"\" border=\"0\" width=\"25\" height=\"25\" style=\"border: 0;\" /> <b>Result:</b></label> \n        <input name=\"result\" placeholder=\"0\" type=\"text\" onClick=\"this.select();\"/>\n      </div>\n        <p class=\"calculation\">${text}</p>\n      </form>`,\n    buttons: {},\n    render: ([dialogContent]) => {\n        dialogContent.querySelector(`input[name=\"target\"`).focus();\n        dialogContent.querySelector(`input[name=\"result\"`).addEventListener(\"input\", (event) => {\n            const textInput = event.target;\n            const form = textInput.closest(\"form\")\n            const calcResult = form.querySelector(\".calculation\");\n            const target = form.querySelector('input[name=\"target\"]').value;\n            const result = form.querySelector('input[name=\"result\"]').value;\n            let raises = Math.floor((parseInt(result) - parseInt(target)) / 4);\n            if (parseInt(target) > parseInt(result)) {\n                calcResult.innerHTML = `<img style=\"border: 0;\" src=\"modules/swim/assets/icons/misc/raise_red.svg\" alt=\"\" width=\"25\" height=\"25\" /> <b>Failure</b>`;\n            }\n            else if (parseInt(target) <= parseInt(result) && raises < 1) {\n                calcResult.innerHTML = `<img style=\"border: 0;\" src=\"modules/swim/assets/icons/misc/raise_yellow.svg\" alt=\"\" width=\"25\" height=\"25\" /> <b>Success</b>`;\n            }\n            else {\n                calcResult.innerHTML = `<img style=\"border: 0;\" src=\"modules/swim/assets/icons/misc/raise_green.svg\" alt=\"\" width=\"25\" height=\"25\" /> <b>${raises} Raise(s)</b>`;\n            }\n        });\n    },\n    // v.1.2.1 By SalieriC#8263, with help from Rawny#2166.\n}).render(true);","author":"wpWSO3unowg8siJN","img":"modules/swim/assets/icons/misc/raise_green.svg","actorIds":[]}
{"_id":"Ev8ZsXHcHZy0Q1yi","name":"Raise Calculator","permission":{"default":0,"wpWSO3unowg8siJN":3},"type":"script","flags":{"combat-utility-belt":{"macroTrigger":""},"furnace":{"runAsGM":false},"macro-marker":{"activeData":{"icon":"Resources%20all%20worlds/Icons/Icons/arrow-cursor.png","tooltip":"Raise Calculator ","colour":"#000000","trigger":""}},"exportSource":{"world":"savage-worlds-the-witcher","system":"swade","coreVersion":"0.6.6","systemVersion":"0.11.3"},"core":{"sourceId":"Macro.jSeaZIQtgtx3j7Cp"}},"scope":"global","command":"const template = `\n      <form>\n       <div class=\"form-group\">\n        <label><img src=\"modules/swim/assets/icons/misc/bullseye.svg\" alt=\"\" width=\"25\" height=\"25\" style=\"border: 0;\" /> <b>Target Number:</b></label> \n        <input name=\"target\" placeholder=\"0\" type=\"text\" autofocus/>\n       </div>\n       <div class=\"form-group\">\n        <label><img src=\"modules/swim/assets/icons/misc/rolling-dices.svg\" alt=\"\" border=\"0\" width=\"25\" height=\"25\" style=\"border: 0;\" /> <b>Result:</b></label> \n        <input name=\"result\" placeholder=\"0\" type=\"text\"/>\n      </div>\n    </form>`;\nnew Dialog({\n  title: 'Raise Calculator',\n  content: template,\n  buttons: {\n    one: {\n      label: 'Submit',\n      callback: html => {\n        let target = html.find('input[name=\"target\"]').val();\n        let result = html.find('input[name=\"result\"]').val();\n        const raises = Math.floor((parseInt(result) - parseInt(target)) / 4)\n        if (parseInt(target) > parseInt(result)) {\n          ui.notifications.notify(`Failure`);\n        }\n        else if (parseInt(target) <= parseInt(result) && raises < 1) {\n          ui.notifications.notify(`Success`);\n        }\n        else {\n          ui.notifications.notify(`${raises} Raise(s)`);\n        }\n      },\n    },\n  },\n  default: \"one\",\n  render: ([dialogContent]) => {\n    dialogContent.querySelector(`input[name=\"target\"`).focus();\n  }\n  // v.1.1.1 By SalieriC#8263, with help from Rawny#2166.\n}).render(true);","author":"wpWSO3unowg8siJN","img":"modules/swim/assets/icons/misc/raise_green.svg","actorIds":[]}
{"_id":"UpFPgFsZcKS1qxaP","name":"Unshake (SWD)","permission":{"default":0,"wpWSO3unowg8siJN":3},"type":"script","flags":{"combat-utility-belt":{"macroTrigger":""},"core":{"sourceId":"Macro.xwvNVeOMp5PjtWaK"}},"scope":"global","command":"main();\n\nasync function main() {\n    // No Token is Selected\n    if (!token || canvas.tokens.controlled.length > 1) {\n        ui.notifications.error(\"Please select a single token first.\");\n        return;\n    }\n\n    // Checking for SWADE Spices & Flavours and setting up the Benny image.\n    let bennyImage = \"icons/commodities/currency/coin-embossed-octopus-gold.webp\";\n    if (game.modules.get(\"swade-spices\")?.active) {\n        let benny_Back = game.settings.get(\n            'swade-spices', 'bennyBack');\n        if (benny_Back) {\n            bennyImage = benny_Back;\n        }\n    }\n    // Setting up SFX path.\n    let shakenSFX = game.settings.get(\n        'swim', 'shakenSFX');\n\n    let bennies;\n    let bv;\n\n    async function rollUnshake() {\n\n        const edgeNames = ['combat reflexes', 'demon', 'undead', 'construct', 'undead (harrowed)'];\n        const actorAlias = speaker.alias;\n        // ROLL SPIRIT AND CHECK COMBAT REFLEXES\n        const r = await token.actor.rollAttribute('spirit');\n        const edges = token.actor.data.items.filter(function (item) {\n            return edgeNames.includes(item.name.toLowerCase()) && (item.type === \"edge\" || item.type === \"ability\");\n        });\n        let rollWithEdge = r.total;\n        let edgeText = \"\";\n        for (let edge of edges) {\n            rollWithEdge += 2;\n            edgeText += `<br/><i>+ ${edge.name}</i>`;\n        }\n\n        let chatData = `${actorAlias} rolled <span style=\"font-size:150%\"> ${rollWithEdge} </span>`;\n        // Checking for a Critical Failure.\n        if (isSame_bool(r.dice) && isSame_numb(r.dice) === 1) {\n            ui.notifications.notify(\"You've rolled a Critical Failure!\");\n            let chatData = `${actorAlias} rolled a <span style=\"font-size:150%\"> Critical Failure! </span>`;\n            ChatMessage.create({ content: chatData });\n        }\n        else {\n            if (rollWithEdge > 3 && rollWithEdge <= 7) {\n                chatData += ` and is no longer Shaken but cannot act this turn.`;\n                token.actor.update({ \"data.status.isShaken\": false });\n                useBenny();\n            } else if (rollWithEdge >= 8) {\n                chatData += `, is no longer Shaken and may act normally.`;\n                token.actor.update({ \"data.status.isShaken\": false });\n            } else {\n                chatData += `, is still Shaken, may only move at half pace but may take free actions.`;\n                useBenny();\n            }\n            chatData += ` ${edgeText}`;\n        }\n        ChatMessage.create({ content: chatData });\n    }\n\n    // Functions to determine a critical failure. This one checks if all dice rolls are the same.\n    function isSame_bool(d = []) {\n        return d.reduce((c, a, i) => {\n            if (i === 0) return true;\n            return c && a.total === d[i - 1].total;\n        }, true);\n    }\n\n    // Functions to determine a critical failure. This one checks what the number of the \"same\" was.\n    function isSame_numb(d = []) {\n        return d.reduce((c, a, i) => {\n            if (i === 0 || d[i - 1].total === a.total) return a.total;\n            return null;\n        }, 0);\n    }\n\n    function useBenny() {\n        bv = checkBennies();\n        if (bv > 0) {\n            new Dialog({\n                title: 'Spend a Benny?',\n                content: `Do you want to spend a Benny to act immediately? (You have ${bv} Bennies left.)`,\n                buttons: {\n                    one: {\n                        label: \"Yes.\",\n                        callback: (html) => {\n                            spendBenny();\n                            token.actor.update({ \"data.status.isShaken\": false });\n                        }\n                    },\n                    two: {\n                        label: \"No.\",\n                        callback: (html) => { return; },\n                    }\n                },\n                default: \"one\"\n            }).render(true)\n        }\n        else {\n            return;\n        }\n    }\n\n    // Check for Bennies\n    function checkBennies() {\n        bennies = token.actor.data.data.bennies.value;\n\n        // Non GM token has <1 bennie OR GM user AND selected token has <1 benny\n        if ((!game.user.isGM && bennies < 1) || (game.user.isGM && bennies < 1 && game.user.getFlag(\"swade\", \"bennies\") < 1)) {\n            ui.notifications.error(\"You have no more bennies left.\");\n        }\n        if (game.user.isGM) {\n            bv = bennies + game.user.getFlag(\"swade\", \"bennies\");\n        }\n        else {\n            bv = bennies;\n        }\n        return bv;\n    }\n\n    // Spend Benny function\n    async function spendBenny() {\n        bennies = token.actor.data.data.bennies.value;\n        //Subtract the spend, use GM benny if user is GM and token has no more bennies left or spend token benny if user is player and/or token has bennies left.\n        if (game.user.isGM && bennies < 1) {\n            game.user.setFlag(\"swade\", \"bennies\", game.user.getFlag(\"swade\", \"bennies\") - 1)\n        } else {\n            token.actor.update({\n                \"data.bennies.value\": bennies - 1,\n            })\n        }\n\n        //Show the Benny Flip\n        if (game.dice3d) {\n            game.dice3d.showForRoll(new Roll(\"1dB\").roll(), game.user, true, null, false);\n        }\n\n        //Chat Message to let the everyone know a benny was spent\n        ChatMessage.create({\n            user: game.user._id,\n            content: `<p><img style=\"border: none;\" src=\"${bennyImage}\"\" width=\"25\" height=\"25\" /> ${game.user.name} spent a Benny and ${token.name} may act normally now.</p>`,\n        });\n    }\n\n    if (token.actor.data.data.status.isShaken === true) {\n        rollUnshake()\n    } else if (token) {\n        token.actor.update({ \"data.status.isShaken\": true })\n        if (shakenSFX) {\n            AudioHelper.play({ src: `${shakenSFX}` }, true);\n        }\n    }\n    /// v.3.3.3 Original code by Shteff, altered by Forien and SalieriC#8263, thanks to Spacemandev for the help as well. Fixed by hirumatto.\n}","author":"wpWSO3unowg8siJN","img":"modules/swim/assets/icons/status_markers/0-Shaken.png","actorIds":[]}
{"_id":"UyGsY9ZIY2oyWwxc","name":"Scale Calculator","permission":{"default":0,"wpWSO3unowg8siJN":3},"type":"script","flags":{"combat-utility-belt":{"macroTrigger":""},"core":{"sourceId":"Macro.QTFeoKrOii26UDIj"}},"scope":"global","command":"const chatimage = \"icons/tools/hand/scale-balances-merchant-brown.webp\";\n\n/* Size Scale p106 SWADE\n\nsource: https://raw.githubusercontent.com/brunocalado/mestre-digital/master/Foundry%20VTT/Macros/Savage%20Worlds/SizeScaleCalculator.js\nicon: icons/tools/hand/scale-balances-merchant-brown.webp\n*/\n\nlet tokenActor = canvas.tokens.controlled[0];\nlet tokenTarget = Array.from(game.user.targets)[0];\nlet coreRules = false;\nif (game.modules.get(\"swade-core-rules\")?.active) { coreRules = true; }\n\nif (tokenActor === undefined || tokenTarget === undefined) {\n    ui.notifications.warn(\"You must select a token and target another one!\");\n} else {\n    const actorSwat = token.actor.data.items.find(function (item) {\n        return ((item.name.toLowerCase() === \"swat\") && item.type === \"ability\");\n    });\n    const targetSwat = tokenTarget.actor.data.items.find(function (item) {\n        return ((item.name.toLowerCase() === \"swat\") && item.type === \"ability\");\n    });\n    rollForIt();\n\n\n    function rollForIt() {\n        let actorSize = tokenActor.actor.data.data.stats.size;\n        let targetSize = tokenTarget.actor.data.data.stats.size;\n        let actorModifier = sizeToModifier(actorSize);\n        let targetModifier = sizeToModifier(targetSize);\n        let modifier = calc(actorModifier, targetModifier);\n\n        let message = `<h2><img style=\"vertical-align:middle\" src=${chatimage} width=\"28\" height=\"28\"> Size & Scale Calculator</h2>`;\n        if (coreRules === true) {\n            message = `<div class=\"swade-core\"><h2><img style=\"vertical-align:middle\" src=${chatimage} width=\"28\" height=\"28\"> @Compendium[swade-core-rules.swade-rules.mbP0fwcquD98QtwX]{Size & Scale} Calculator</h2>`;\n        }\n        message += `<ul><li><b>${tokenActor.name}:</b> Size = ${actorSize} / Modifier = ${actorModifier}</li>`;\n        message += `<li><b>${tokenTarget.name}:</b> Size = ${targetSize} / Modifier = ${targetModifier}</li></ul>`;\n        message += `<h3>Result:</h3>`;\n        if (modifier != 0) {\n            message += `<ul><li>${tokenActor.name} has <b style=\"color:red\">${modifier}</b> to attack ${tokenTarget.name}`;\n            if (actorSwat) {\n                message += ` and has Swat*.</li>`;\n            } else { message += `.</li>` }\n            message += `<li>${tokenTarget.name} has <b style=\"color:red\">${calc(targetModifier, actorModifier)}</b> to attack ${tokenActor.name}`;\n            if (targetSwat) {\n                message += ` and has Swat*.</li></ul>`;\n            } else { message += `.</li></ul>` }\n            if ((actorSwat && targetSwat) || (actorSwat || targetSwat)) {\n                if (coreRules === true) {\n                    message += `<p>*<b>@Compendium[swade-core-rules.swade-rules.q5sk5hEw6TED0FOU]{Swat}:</b> Ignore up to 4 points of penalties from Scale for the specified action(s).</p>`;\n                } else {\n                    message += `<p>*<b>Swat:</b> Ignore up to 4 points of penalties from Scale for the specified action(s).</p>`;\n                }\n                if (coreRules === true) {\n                    message += `</div>`;\n                }\n            }\n        } else {\n            message += `<p><b>There is no modifier.</b> They have the same Scale.</p>`;\n        }\n\n        // send message\n        let chatData = {\n            user: game.user._id,\n            content: message\n        };\n        ChatMessage.create(chatData, {});\n    }\n\n    function calc(actorModifier, targetModifier) {\n        let diff;\n        if (actorModifier == targetModifier) {\n            return 0;\n        } else {\n            if (actorModifier < targetModifier) {\n                diff = Math.abs(actorModifier) + Math.abs(targetModifier);\n                return diff;\n            } else {\n                diff = Math.abs(actorModifier) + Math.abs(targetModifier);\n                return -diff;\n            }\n        }\n    }\n\n    function sizeToModifier(size) { //p179 swade core\n        if (size == -4) {\n            return -6;\n        } else if (size == -3) {\n            return -4;\n        } else if (size == -2) {\n            return -2;\n        } else if (size >= -1 && size <= 3) {\n            return 0;\n        } else if (size >= 4 && size <= 7) {\n            return 2;\n        } else if (size >= 8 && size <= 11) {\n            return 4;\n        } else if (size >= 12 && size <= 20) {\n            return 6;\n        }\n    }\n    // v. 1.0.0 - Original code by brunocalado, modified by SalieriC#8263.\n}","author":"wpWSO3unowg8siJN","img":"icons/tools/hand/scale-balances-merchant-brown.webp","actorIds":[]}
{"_id":"aYvSL8Qpc2I6WWCi","name":"Soak Damage","permission":{"default":0,"wpWSO3unowg8siJN":3},"type":"script","flags":{"combat-utility-belt":{"macroTrigger":""},"core":{"sourceId":"Macro.amSPIEmiOJ50t3bJ"}},"scope":"global","command":"main();\n\nfunction main() {\n    // Checking if at least one token is defined.\n    if (canvas.tokens.controlled.length === 0) {\n        ui.notifications.error(\"Please select a token first\");\n        return;\n    }\n    // Checking for SWADE Spices & Flavours and setting up the Benny image.\n    let bennyImage = \"icons/commodities/currency/coin-embossed-octopus-gold.webp\";\n    if (game.modules.get(\"swade-spices\")?.active) {\n        let benny_Back = game.settings.get(\n            'swade-spices', 'bennyBack');\n        if (benny_Back) {\n            bennyImage = benny_Back;\n        }\n    }\n    // Setting SFX\n    let woundedSFX = game.settings.get(\n        'swim', 'woundedSFX');\n    let incapSFX = game.settings.get(\n        'swim', 'incapSFX');\n    // Injury Table for Gritty Damage\n    let grit = game.settings.get(\n        'swim', 'grittyDamage');\n    let injuryTable = game.settings.get(\n        'swim', 'injuryTable');\n\n    // Check if a token is selected.\n    if (!token || canvas.tokens.controlled.length > 1) {\n        ui.notifications.error(\"Please select a single token first.\");\n    }\n\n    // Declairing variables and constants.\n    const wv = token.actor.data.data.wounds.value;\n    const wm = token.actor.data.data.wounds.max;\n    const ppv = token.actor.data.data.powerPoints.value;\n    const holyWarr = token.actor.data.items.find(function (item) {\n        return ((item.name.toLowerCase() === \"holy warrior\") || (item.name.toLowerCase() === \"unholy warrior\")) && item.type === \"edge\";\n    });\n    const elan = token.actor.data.items.find(function (item) {\n        return item.name.toLowerCase() === \"elan\" && item.type === \"edge\";\n    });\n    let bennies = token.actor.data.data.bennies.value;\n    let bv;\n    let numberWounds;\n    let numberPP;\n    let rounded;\n    let elanBonus;\n    let newWounds;\n\n    // This is the main function that handles the Vigor roll.\n    async function rollSoak() {\n\n        const edgeNames = ['iron jaw', 'thick fur'];\n        const actorAlias = speaker.alias;\n        // Roll Vigor and check for Iron Jaw.\n        const r = await token.actor.rollAttribute('vigor');\n        const edges = token.actor.data.items.filter(function (item) {\n            return edgeNames.includes(item.name.toLowerCase()) && (item.type === \"edge\" || item.type === \"ability\");\n        });\n        let rollWithEdge = r.total;\n        let edgeText = \"\";\n        for (let edge of edges) {\n            rollWithEdge += 2;\n            edgeText += `<br/><i>+ ${edge.name}</i>`;\n        }\n\n        // If Holy Warrior or Unholy Warrior is used: Include the amount of PPs used as a bonus to the roll.\n        if (typeof numberPP === \"number\") {\n            rollWithEdge += numberPP;\n            edgeText = edgeText + `<br/><i>+ ${numberPP}</i> from spent Power Points.`;\n        }\n\n        // Apply +2 if Elan is present and if it is a reroll.\n        if (typeof elanBonus === \"number\") {\n            rollWithEdge += 2;\n            edgeText = edgeText + `<br/><i>+ Elan</i>.`;\n        }\n\n        // Roll Vigor including +2 if Iron Jaw is present, amount of PPs used as modifier if Holy Warrior or Unholy Warrior was used and another +2 if this is a reroll.\n        let chatData = `${actorAlias} rolled <span style=\"font-size:150%\"> ${rollWithEdge} </span>`;\n        rounded = Math.floor(rollWithEdge / 4);\n\n        // Making rounded 0 if it would be negative.\n        if (rounded < 0) {\n            rounded = 0;\n        }\n\n        // Checking for a Critical Failure.\n        if (isSame_bool(r.dice) && isSame_numb(r.dice) === 1) {\n            ui.notifications.notify(\"You've rolled a Critical Failure! Applying wounds now...\");\n            let chatData = `${actorAlias} rolled a <span style=\"font-size:150%\"> Critical Failure! </span>`;\n            applyWounds();\n            ChatMessage.create({ content: chatData });\n        }\n        else {\n            if (rounded < 1) {\n                bv = checkBennies();\n                chatData += ` and is unable to soak any Wounds.`;\n                if (bv < 1) {\n                    applyWounds();\n                }\n                else {\n                    dialogReroll();\n                }\n            } else if (rounded < numberWounds) {\n                chatData += ` and soaks ${rounded} of his Wounds.`;\n                if (bv < 1) {\n                    applyWounds();\n                }\n                else {\n                    dialogReroll();\n                };\n            } else if (rounded >= numberWounds) {\n                chatData += ` and soaks all of his Wounds.`;\n                if (token.actor.data.data.status.isShaken === true) {\n                    token.actor.update({ \"data.status.isShaken\": false });\n                }\n            }\n            chatData += ` ${edgeText}`;\n\n            ChatMessage.create({ content: chatData });\n        }\n    }\n\n    // Functions to determine a critical failure. This one checks if all dice rolls are the same.\n    function isSame_bool(d = []) {\n        return d.reduce((c, a, i) => {\n            if (i === 0) return true;\n            return c && a.total === d[i - 1].total;\n        }, true);\n    }\n\n    // Functions to determine a critical failure. This one checks what the number of the \"same\" was.\n    function isSame_numb(d = []) {\n        return d.reduce((c, a, i) => {\n            if (i === 0 || d[i - 1].total === a.total) return a.total;\n            return null;\n        }, 0);\n    }\n\n    // Apply wounds if not all wounds were soaked.\n    async function applyWounds() {\n        newWounds = numberWounds - rounded;\n        new Dialog({\n            title: 'Applying Wounds',\n            content: `<form>\n            <div class=\"form-group\">\n                <label for=\"applWounds\">Wounds to apply:</label>\n                <input id=\"applWounds\" name=\"num\" type=\"number\" min=\"0\" value=\"${newWounds}\"></input>\n            </div>\n            </form>`,\n            buttons: {\n                one: {\n                    label: \"Apply Wounds\",\n                    callback: (html) => {\n                        let applWounds = Number(html.find(\"#applWounds\")[0].value);\n                        let setWounds = wv + applWounds;\n                        if (setWounds <= wm && setWounds > 0) {\n                            token.actor.update({ \"data.wounds.value\": setWounds });\n                            token.actor.update({ \"data.status.isShaken\": true })\n                            if (woundedSFX) {\n                                AudioHelper.play({ src: `${woundedSFX}` }, true);\n                            }\n                        }\n                        else if (applWounds === 0) {\n                            token.actor.update({ \"data.status.isShaken\": true })\n                        }\n                        else {\n                            token.actor.update({ \"data.wounds.value\": wm });\n                            game.cub.addCondition(\"Incapacitated\");\n                            if (incapSFX) {\n                                AudioHelper.play({ src: `${incapSFX}` }, true);\n                            }\n                        }\n                        if (!game.user.isGM && setWounds > 0 && grit === true) {\n                            game.tables.getName(`${injuryTable}`).draw();\n                        }\n                    }\n                }\n            },\n            default: \"one\",\n            render: ([dialogContent]) => {\n                dialogContent.querySelector(`input[name=\"num\"`).focus();\n                dialogContent.querySelector(`input[name=\"num\"`).select();\n            },\n        }).render(true)\n    }\n\n    // Check for Bennies\n    function checkBennies() {\n        bennies = token.actor.data.data.bennies.value;\n\n        // Non GM token has <1 bennie OR GM user AND selected token has <1 benny\n        if ((!game.user.isGM && bennies < 1) || (game.user.isGM && bennies < 1 && game.user.getFlag(\"swade\", \"bennies\") < 1)) {\n            ui.notifications.error(\"You have no more bennies left. Wounds will be applied now...\");\n        }\n        if (game.user.isGM) {\n            bv = bennies + game.user.getFlag(\"swade\", \"bennies\");\n        }\n        else {\n            bv = bennies;\n        }\n        return bv;\n    }\n\n    // Spend Benny function\n    async function spendBenny() {\n        bennies = token.actor.data.data.bennies.value;\n        //Subtract the spend, use GM benny if user is GM and token has no more bennies left or spend token benny if user is player and/or token has bennies left.\n        if (game.user.isGM && bennies < 1) {\n            game.user.setFlag(\"swade\", \"bennies\", game.user.getFlag(\"swade\", \"bennies\") - 1)\n        } else {\n            token.actor.update({\n                \"data.bennies.value\": bennies - 1,\n            })\n        }\n\n        //Show the Benny Flip\n        if (game.dice3d) {\n            game.dice3d.showForRoll(new Roll(\"1dB\").roll(), game.user, true, null, false);\n        }\n\n        //Chat Message to let the everyone know a benny was spent\n        ChatMessage.create({\n            user: game.user._id,\n            content: `<p><img style=\"border: none;\" src=\"${bennyImage}\"\" width=\"25\" height=\"25\" /> ${game.user.name} spent a Benny for ${token.name}.</p>`,\n        });\n    }\n\n    // Buttons for the main Dialogue.\n    let buttonsMain = {\n        one: {\n            label: \"Soak Wounds\",\n            callback: (html) => {\n                numberWounds = Number(html.find(\"#numWounds\")[0].value);\n                bv = checkBennies();\n                if (bv < 1) {\n                    applyWounds();\n                }\n                else {\n                    spendBenny();\n                    rollSoak();\n                }\n            }\n        },\n        two: {\n            label: \"Apply Damage\",\n            callback: (html) => {\n                numberWounds = Number(html.find(\"#numWounds\")[0].value);\n                rounded = 0\n                applyWounds();\n            }\n        }\n    }\n\n    // If Unholy Warrior or Holy Warrior is present, add another button to the Main Dialogue and render another dialogue to enter the amount of PP to be used.\n    if (holyWarr) buttonsMain[\"three\"] = {\n        label: \"Soak with (Un)Holy Warrior\",\n        callback: (html) => {\n            numberWounds = Number(html.find(\"#numWounds\")[0].value);\n            new Dialog({\n                title: 'Soaking Wounds',\n                content: `<form>\n            <div class=\"form-group\">\n                <form>\n                You can spend a <b>maximum of 4 Power Points</b> to add a bonus to your Soaking Roll equal to the amount of Power Points used.\n                </br>You have <b>${ppv} Power Points</b> left.\n                </form>\n                <label for=\"numPP\">Power Points to spend: </label>\n                <input id=\"numPP\" name=\"num\" type=\"number\" min=\"1\" max=\"4\" value=\"1\"></input>\n            </div>\n            </form>`,\n                buttons: {\n                    one: {\n                        label: \"Soak Wounds\",\n                        callback: (html) => {\n                            numberPP = Number(html.find(\"#numPP\")[0].value);\n                            if (ppv < numberPP) {\n                                ui.notifications.notify(\"You have insufficient Power Points.\");\n                            }\n                            else if (numberPP > 4) {\n                                ui.notifications.error(\"You can't use more than 4 Power Points.\");\n                            }\n                            else {\n                                bv = checkBennies();\n                                if (bv < 1) {\n                                    applyWounds();\n                                }\n                                else {\n                                    let newPP = ppv - numberPP;\n                                    token.actor.update({ \"data.powerPoints.value\": newPP });\n                                    spendBenny();\n                                    rollSoak(numberWounds, numberPP);\n                                }\n                            }\n                        }\n                    },\n                    default: \"one\",\n                    render: ([dialogContent]) => {\n                        dialogContent.querySelector(`input[name=\"num\"`).focus();\n                        dialogContent.querySelector(`input[name=\"num\"`).select();\n                    },\n                }\n            }).render(true);\n        }\n    }\n\n    // Main Dialogue\n    new Dialog({\n        title: 'Soaking Wounds',\n        content: `<form>\n        <p>You currently have <b>${wv}/${wm}</b> Wounds and <b>${bennies}</b> Bennies.</p>\n    <div class=\"form-group\">\n        <label for=\"numWounds\">Amount of Wounds: </label>\n        <input id=\"numWounds\" name=\"num\" type=\"number\" min=\"0\" value=\"1\"></input>\n    </div>\n    </form>`,\n        buttons: buttonsMain,\n        default: \"one\",\n        render: ([dialogContent]) => {\n            dialogContent.querySelector(`input[name=\"num\"`).focus();\n            dialogContent.querySelector(`input[name=\"num\"`).select();\n        },\n    }).render(true);\n\n    // Dialog to be rendered if not all wounds were soaked in rollSoak.\n    function dialogReroll() {\n        bv = checkBennies();\n        if (bv > 0) {\n            let currWounds = numberWounds - rounded;\n            new Dialog({\n                title: 'Reroll',\n                content: `<form>\n                    You've soaked <b>${rounded} Wounds</b>; you will <b>receive ${currWounds} Wounds</b>.\n                    </br>Do you want to reroll your Soaking Roll (you have <b>${bv} Bennies</b> left)?\n                    </form>`,\n                buttons: {\n                    one: {\n                        label: \"Reroll\",\n                        callback: (html) => {\n                            spendBenny();\n                            if (!!elan) {\n                                elanBonus = 2;\n                            }\n                            rollSoak();\n                        }\n                    },\n                    two: {\n                        label: \"No, apply Wounds now\",\n                        callback: (html) => {\n                            ui.notifications.notify(\"Wounds will be applied now.\");\n                            applyWounds();\n                        }\n                    }\n                },\n                default: \"one\",\n            }).render(true);\n        }\n        else {\n            ui.notifications.notify(\"You have no more bennies, Wounds will be applied now.\");\n            applyWounds();\n        }\n    }\n    // V2.5.4 Code by SalieriC#8263. Critical Failure awareness by Kekilla#7036 Testing and bug-chasing: javierrivera#4813.\n}","author":"wpWSO3unowg8siJN","img":"modules/swim/assets/icons/status_markers/3-Incapacitated.png","actorIds":[]}
{"_id":"ctJW8dedsvnhuRxW","name":"Mark Dead","permission":{"default":0,"wpWSO3unowg8siJN":3},"type":"script","flags":{"combat-utility-belt":{"macroTrigger":""},"core":{"sourceId":"Macro.8azlZlxGRBdmCaVi"}},"scope":"global","command":"/**\n*  This macro will mark the selected token as dead.\n*  If the selected token is dead, it will be marked\n   as alive instead.\n*  It requires CUB to be set up and Health Estimate.\n*  Originally from Health Estimate, altered by SalieriC.\n*/\n\n//Set up\nlet incapSFX = game.settings.get(\n  'swim', 'incapSFX');\n\nmain();\n\nfunction main() {\n  if (canvas.tokens.controlled.length === 0) {\n    ui.notifications.error(\"Please select a token first\");\n    return;\n  }\n\n  let hasAlive = false;\n  for (let e of canvas.tokens.controlled) {\n    if (!e.getFlag(\"healthEstimate\", \"dead\")) {\n      hasAlive = true;\n      break\n    }\n  }\n  for (let e of canvas.tokens.controlled) {\n    e.setFlag(\"healthEstimate\", \"dead\", hasAlive)\n    async function toggleCondition(condition, token, { warn = true } = {}) {\n      if (!condition || !token) return;\n\n      game.cub.hasCondition(condition, token, { warn })\n        ? await game.cub.removeCondition(condition, token, { warn })\n        : await game.cub.addCondition(condition, token, { warn });\n\n      return game.cub.hasCondition(condition, token, { warn });\n    }\n\n    toggleCondition(`Incapacitated`, e);\n  }\n  ui.notifications.info(\"Marked as dead/alive.\");\n  AudioHelper.play({ src: `${incapSFX}` }, true);\n\n  // v.2.0.1\n}","author":"wpWSO3unowg8siJN","img":"icons/commodities/bones/skull-hollow-brown.webp","actorIds":[]}
{"_id":"dlz1EuSQ09IgpvXb","name":"Spend Benny","permission":{"default":0,"wpWSO3unowg8siJN":3},"type":"script","flags":{"combat-utility-belt":{"macroTrigger":""},"core":{"sourceId":"Macro.nAubNq7dYQUz6DaP"}},"scope":"global","command":"/* This macro will spend a benny for the selected token and gives an error message if there are none left.\nIf the user is a GM, it will also spend GM bennies if he has some left but the token does not.\nIf Dice So Nice is installed, it will also trigger the benny roll animation. */\n\nmain();\n\nasync function main() {\n    // No Token is Selected\n    if (!token || canvas.tokens.controlled.length > 1) {\n        ui.notifications.error(\"Please select a single token first.\");\n        return;\n    }\n\n    // Checking for SWADE Spices & Flavours and setting up the Benny image.\n    let bennyImage = \"icons/commodities/currency/coin-embossed-octopus-gold.webp\";\n    if (game.modules.get(\"swade-spices\")?.active) {\n        let benny_Back = game.settings.get(\n            'swade-spices', 'bennyBack');\n        if (benny_Back) {\n            bennyImage = benny_Back;\n        }\n    }\n\n    let bennies = token.actor.data.data.bennies.value;\n\n    // Non GM token has <1 bennie OR GM user AND selected token has <1 benny\n    if ((!game.user.isGM && bennies < 1) || (game.user.isGM && bennies < 1 && game.user.getFlag(\"swade\", \"bennies\") < 1)) {\n        ui.notifications.error(\"You have no more bennies left.\")\n        return;\n    }\n\n    //Subtract the spend, use GM benny if user is GM and token has no more bennies left or spend token benny if user is player and/or token has bennies left.\n    if (game.user.isGM && bennies < 1) {\n        game.user.setFlag(\"swade\", \"bennies\", game.user.getFlag(\"swade\", \"bennies\") - 1)\n    } else {\n        token.actor.update({\n            \"data.bennies.value\": bennies - 1,\n        })\n    }\n\n    //Show the Benny Flip\n    if (game.dice3d) {\n        game.dice3d.showForRoll(new Roll(\"1dB\").roll(), game.user, true, null, false);\n    }\n\n    //Chat Message to let the everyone know a benny was spent\n    ChatMessage.create({\n        user: game.user._id,\n        content: `<p><img style=\"border: none;\" src=\"${bennyImage}\"\" width=\"25\" height=\"25\" /> ${game.user.name} spent a Benny for ${token.name}.</p>`,\n    });\n    // Code by Spacemandev#6256, idea and fixing the code by SalieriC#8263, Dice So Nice benny roll by javierrivera#4813.\n}","author":"wpWSO3unowg8siJN","img":"icons/commodities/currency/coin-embossed-octopus-gold.webp","actorIds":[]}
{"name":"Ammo Management (enhanced) [READ THE DOC!]","permission":{"default":0,"wpWSO3unowg8siJN":3},"type":"script","flags":{"combat-utility-belt":{"macroTrigger":""},"core":{"sourceId":"Macro.XEYSVDTmQli1bqlu"}},"scope":"global","command":"// Preset for SFX of weapons (Without the //):\n//RELOAD|FIRE|AUTOFIRE|SILENCED|SILENCEDAUTOFIRE|EMPTY\n\nlet dialogID = \"\";\n\nasync function weaponDialog() {\n  if (!token) return ui.notifications.error(\"Please select a token first\");\n\n  const actor = token.actor;\n  const weapons = actor.items.filter(i =>\n    (i.type === \"weapon\" &&\n      //i.data.data.range !== \"0\" && i.data.data.range !== \"\" &&\n      i.data.data.ammo.trim() !== \"\" &&\n      i.data.data.quantity > 0) ||\n    (i.type === \"weapon\" &&\n      //i.data.data.range !== \"0\" && i.data.data.range !== \"\" &&\n      i.data.data.additionalStats.isConsumable &&\n      i.data.data.additionalStats.isConsumable.value === true &&\n      i.data.data.quantity > 0)\n  );\n\n  if (weapons.length === 0) return ui.notifications.error(\"You have no reloadable or consumable weapons.\");\n\n  let html = getHTML();\n  let content = getContent();\n  let buttons = getButtons();\n\n  let dialog = new Dialog({\n    content, buttons, title: `Attack Dialog`\n  }, {\n    width: 400,\n  });\n\n  dialogID = dialog.appId;\n\n  await dialog._render(true);\n  activeListeners();\n\n  function getHTML() {\n    let html = document.getElementById(`app-${dialogID}`)?.getElementsByTagName(`select`);\n    if (html === undefined) return undefined;\n    else return Array.from(html).map(h => h.value);\n  }\n  function getContent() {\n    let selectedWeapon = html !== undefined\n      ? html[0]\n      : weapons[0].id;\n\n    //console.log(html, selectedWeapon, weapons);\n\n    //Get ammo and filter for the ammo the token actually owns.\n    let ammo = weapons\n      .find(w => w.id === selectedWeapon).data.data.ammo.trim().split(`|`)\n      .filter(a => !!actor.items.getName(a));\n\n    let rate_of_fire = parseInt(weapons.find(w => w.id === selectedWeapon).data.data.rof);\n    let defaultShots = 1;\n    if (rate_of_fire === 2) { defaultShots = 5; }\n    if (rate_of_fire === 3) { defaultShots = 10; }\n    if (rate_of_fire === 4) { defaultShots = 20; }\n    if (rate_of_fire === 5) { defaultShots = 40; }\n    if (rate_of_fire === 6) { defaultShots = 50; }\n\n    return `\n    <form>\n      <div>\n        <p>Here you can fire shots from your weapon or reload it.</p>\n        <p>You don't need to adjust the \"# of Shots\" for realoading. If you change the ammo type you'll keep the old ammo unless it is a Charge Pack.</p>\n        <p><b># of Shots per ROF:</b> ROF 1 = 1 Shot; ROF 2 = 5; ROF 3 = 10; ROF 4 = 20; ROF 5 = 40; ROF 6 = 50</p>\n      </div>\n      <div class=\"form-group\">\n        <label for=\"shots\"># of Shots: </label>\n        <input id=\"shots\" type=\"number\" min=\"0\" value=\"${defaultShots}\"></input>\n      </div>\n      <div class=\"form-group\">\n        <label for=\"weapon\">Weapon: </label>\n        <select id=\"weapon\">${weapons.reduce((acc, val) => acc += `<option value=\"${val.id}\" ${val.id === selectedWeapon ? `selected` : ``}>${val.name}</option>`, ``)}</select>\n      </div>\n      <div class=\"form-group\">\n        <label for=\"ammo\">Ammo: </label>\n        <select id=\"ammo\">${ammo.reduce((acc, val) => acc += `<option value=\"${val}\">${val}</option>`, ``)}</select>\n      </div>\n    </form>\n    `\n  }\n  function getButtons() {\n    return {\n      a: {\n        label: \"Shoot\", callback: shoot,\n      },\n      b: {\n        label: \"Reload\", callback: reload,\n      }\n    }\n  }\n  function activeListeners() {\n    document.getElementById(\"weapon\").onchange = update;\n  }\n  async function update() {\n    html = getHTML();\n    dialog.data.content = getContent();\n    dialog.data.buttons = getButtons();\n    await dialog._render(true);\n    activeListeners();\n  }\n  async function shoot(html) {\n    let [shots, weapon, ammo] = getValues(html);\n    let item_weapon = actor.items.get(weapon);\n    let item_ammo = actor.items.get(ammo)\n    // Getting the sfx from the selected weapon\n    let sfx_shot/* = stuff*/;\n    let sfx_silenced/* = stuff*/;\n    let sfx_shot_auto/* = stuff*/;\n    let sfx_silenced_auto/* = stuff*/;\n    let sfx_empty;\n    if (item_weapon.data.data.additionalStats.sfx) {\n      let sfx = item_weapon.data.data.additionalStats.sfx.value.split(`|`);\n      sfx_shot = sfx[1];\n      sfx_silenced = sfx[3];\n      sfx_shot_auto = sfx[2];\n      sfx_silenced_auto = sfx[4];\n      sfx_empty = sfx[5];\n    }\n    // Setting a boolean depending on whether or not a weapon is silenced\n    let sil = false;\n    if (item_weapon.data.data.additionalStats.silenced && item_weapon.data.data.additionalStats.silenced.value === true) {\n      sil = true;\n    }\n    // Getting Weapon and loaded ammo\n    const weaponIMG = item_weapon.data.img;\n    let currentAmmo\n    if (item_weapon.data.data.additionalStats.loadedAmmo) {\n      currentAmmo = item_weapon.data.data.additionalStats.loadedAmmo.value;\n    }\n\n    // Calculating shots to expend\n    const currentCharges = parseInt(item_weapon.data.data.currentShots);\n    const newCharges = currentCharges - shots;\n    if (item_weapon.data.data.additionalStats.isConsumable && item_weapon.data.data.additionalStats.isConsumable.value === true) {\n      const currentQuantity = parseInt(item_weapon.data.data.quantity);\n      if (currentQuantity <= 0) {\n        return ui.notifications.error(`You don't have a ${item_weapon.name} left.`);\n      }\n      const newQuantity = currentQuantity - shots;\n      const updates = [\n        { _id: item_weapon.id, \"data.quantity\": `${newQuantity}` },\n      ];\n      // Updating the consumable weapon\n      await actor.updateOwnedItem(updates);\n      // Deleting the consumable weapon if it was the last\n      if (newQuantity <= 0) {\n        item_weapon.delete();\n      }\n      // Creating the Chat message\n      ChatMessage.create({\n        speaker: {\n          alias: token.name\n        },\n        content: `<img src=\"${weaponIMG}\" alt=\"\" width=\"25\" height=\"25\" /> ${token.name} uses ${shots} ${item_weapon.name}(s) and has ${newQuantity} left.`\n      })\n      // Play sound effects\n      if (sfx_shot) {\n        AudioHelper.play({ src: `${sfx_shot}` }, true);\n      }\n    }\n    // Check if enough bullets are in the weapon to fire the given amount of shots if this is not a consumable weapon.\n    else if (currentCharges < shots) {\n      ui.notifications.error(\"You have insufficient ammunition.\")\n      if (sfx_empty && currentCharges === 0) {\n        AudioHelper.play({ src: `${sfx_empty}` }, true);\n      }\n      return;\n    }\n    else {\n      const updates = [\n        { _id: item_weapon.id, \"data.currentShots\": `${newCharges}` },\n      ];\n      // Updating the Weapon\n      actor.updateOwnedItem(updates);\n      // Creating the Chat message\n      if (!currentAmmo) {\n        ChatMessage.create({\n          speaker: {\n            alias: token.name\n          },\n          content: `<img src=\"${weaponIMG}\" alt=\"\" width=\"25\" height=\"25\" /> ${token.name} fires <b>${shots} round(s)</b> from a ${item_weapon.name} and has <b>${newCharges} left</b>.`\n        })\n      } else {\n        ChatMessage.create({\n          speaker: {\n            alias: token.name\n          },\n          content: `<img src=\"${weaponIMG}\" alt=\"\" width=\"25\" height=\"25\" /> ${token.name} fires <b>${shots} ${currentAmmo} round(s)</b> from a ${item_weapon.name} and has <b>${newCharges} left</b>.`\n        })\n      }\n      // Play sound effects\n      if (sil === true && sfx_silenced) {\n        if (shots > 4 && sfx_silenced_auto) {\n          AudioHelper.play({ src: `${sfx_silenced_auto}` }, true);\n        }\n        else {\n          AudioHelper.play({ src: `${sfx_silenced}` }, true);\n        }\n      }\n      else {\n        if (shots > 4 && sfx_shot_auto) {\n          AudioHelper.play({ src: `${sfx_shot_auto}` }, true);\n        }\n        else {\n          AudioHelper.play({ src: `${sfx_shot}` }, true);\n        }\n      }\n    }\n\n    // console.log(\"Shoot | \", shots, weapon, ammo, sil, item_weapon);\n  }\n  function reload(html) {\n    let [shots, weapon, ammo] = getValues(html);\n    // If no ammo left throw an error message.\n    if (!ammo) {\n      return ui.notifications.error(\"You have no ammo left to reload this weapon.\");\n    }\n    let item_weapon = actor.items.get(weapon);\n    // Do not allow consumable weapons to be reloaded\n    if (item_weapon.data.data.additionalStats.isConsumable && item_weapon.data.data.additionalStats.isConsumable.value === true) {\n      return ui.notifications.error(\"You cannot reload consumable weapons, please use Shooting instead.\");\n    }\n    let item_ammo = actor.items.getName(`${ammo}`);\n    //console.log(weapon, item_weapon, ammo, item_ammo);\n    const oldAmmo = item_weapon.data.data.additionalStats.loadedAmmo.value;\n    let item_oldAmmo;\n    if (!oldAmmo) {\n      item_oldAmmo = item_ammo;\n    }\n    else {\n      item_oldAmmo = actor.items.getName(`${oldAmmo}`);\n    }\n    // We suspect that the ammo to reload is the same as the previously loaded one. If not chgType will tell the code to swap the ammo.\n    let chgType = false;\n    if (item_oldAmmo != item_ammo) {\n      chgType = true;\n    }\n    // Getting the sfy from the selected weapon\n    let sfx_reload/* = stuff*/;\n    if (item_weapon.data.data.additionalStats.sfx) {\n      let sfx = item_weapon.data.data.additionalStats.sfx.value.split(`|`);\n      sfx_reload = sfx[0];\n    }\n    // Getting images from items\n    const weaponIMG = item_weapon.data.img;\n    const ammoIMG = item_ammo.data.img;\n\n    // Getting current numbers\n    const currentCharges = parseInt(item_weapon.data.data.currentShots);\n    const requiredCharges = parseInt(item_weapon.data.data.shots - currentCharges);\n    const availableAmmo = parseInt(item_ammo.data.data.quantity);\n    const oldAmmoQuantity = parseInt(item_oldAmmo.data.data.quantity);\n    // Variables for recharging procedure\n    let amountToRecharge;\n    let newCharges;\n    let newAmmo;\n    let oldAmmoRefill;\n    // Checking if the Ammo is a charge pack. If not or additionalStat is not present ignore it. Charge Packs cannot refill so refill chgType is ignored.\n    if (item_ammo.data.data.additionalStats.isPack && item_ammo.data.data.additionalStats.isPack.value === true) {\n      // Charge Packs only use 1 Quantity to fully charge the weapon\n      amountToRecharge = parseInt(item_weapon.data.data.shots);\n      newCharges = amountToRecharge;\n      newAmmo = availableAmmo - 1;\n    }\n    // Checking if user selected to change the ammo type. Charge Packs cannot refill so refill from chgType is ignored.\n    else if (chgType === true) {\n      // When changing Ammo type, remaining shots should not become the new Ammo Type.\n      amountToRecharge = parseInt(item_weapon.data.data.shots);\n      newCharges = amountToRecharge;\n      newAmmo = availableAmmo - amountToRecharge;\n      oldAmmoRefill = oldAmmoQuantity + currentCharges;\n    }\n    else {\n      // If the quantity of ammo is less than the amount required, use whatever is left.\n      amountToRecharge = Math.min(availableAmmo, requiredCharges);\n      newCharges = currentCharges + amountToRecharge;\n      newAmmo = availableAmmo - amountToRecharge;\n    }\n    // Check if there is ammo left to reload.\n    if (availableAmmo < 1) {\n      ui.notifications.notify(\"You are out of ammunition.\")\n    }\n    else if (chgType === true) {\n      const updates = [\n        { _id: item_weapon.id, \"data.currentShots\": `${newCharges}`, \"data.additionalStats.loadedAmmo.value\": `${ammo}` },\n        { _id: item_ammo.id, \"data.quantity\": `${newAmmo}` },\n        { _id: item_oldAmmo.id, \"data.quantity\": `${oldAmmoRefill}` },\n      ];\n\n      actor.updateOwnedItem(updates);\n      ChatMessage.create({\n        speaker: {\n          alias: token.name\n        },\n        content: `<img src=\"${weaponIMG}\" alt=\"\" width=\"25\" height=\"25\" /><img src=\"${ammoIMG}\" alt=\"\" width=\"25\" height=\"25\" /> ${token.name} reloads his/her ${item_weapon.name} with ${item_ammo.name}.`\n      })\n      if (sfx_reload) {\n        AudioHelper.play({ src: `${sfx_reload}` }, true)\n      }\n    }\n    else {\n      const updates = [\n        { _id: item_weapon.id, \"data.currentShots\": `${newCharges}`, \"data.additionalStats.loadedAmmo.value\": `${ammo}` },\n        { _id: item_ammo.id, \"data.quantity\": `${newAmmo}` },\n      ];\n\n      actor.updateOwnedItem(updates);\n      ChatMessage.create({\n        speaker: {\n          alias: token.name\n        },\n        content: `<img src=\"${weaponIMG}\" alt=\"\" width=\"25\" height=\"25\" /><img src=\"${ammoIMG}\" alt=\"\" width=\"25\" height=\"25\" /> ${token.name} reloads his/her ${item_weapon.name} with ${item_ammo.name}.`\n      })\n      if (sfx_reload) {\n        AudioHelper.play({ src: `${sfx_reload}` }, true)\n      }\n    }\n\n    // Ammo with no more bullets left are NOT deleted because that could cause issues when trying to change the ammo.\n  }\n  function getValues(html) {\n    return [\n      html.find(`#shots`)[0].valueAsNumber,\n      html.find(`#weapon`)[0].value,\n      html.find(`#ammo`)[0].value,\n    ];\n  }\n  // V. 1.0.0 By SalieriC#8263. Dialogue Framework: Kekilla#7036\n}\n\nweaponDialog();","author":"wpWSO3unowg8siJN","img":"icons/weapons/crossbows/crossbow-white.webp","actorIds":[],"_id":"gB5U6GYNh86mA8F2"}
{"_id":"lE4PLpy8xfttJQzP","name":"Unshake (SWADE)","permission":{"default":0,"wpWSO3unowg8siJN":3},"type":"script","flags":{"combat-utility-belt":{"macroTrigger":""},"core":{"sourceId":"Macro.xwvNVeOMp5PjtWaK"}},"scope":"global","command":"main();\n\nasync function main() {\n    // No Token is Selected\n    if (!token || canvas.tokens.controlled.length > 1) {\n        ui.notifications.error(\"Please select a single token first.\");\n        return;\n    }\n\n    // Checking for SWADE Spices & Flavours and setting up the Benny image.\n    let bennyImage = \"icons/commodities/currency/coin-embossed-octopus-gold.webp\";\n    if (game.modules.get(\"swade-spices\")?.active) {\n        let benny_Back = game.settings.get(\n            'swade-spices', 'bennyBack');\n        if (benny_Back) {\n            bennyImage = benny_Back;\n        }\n    }\n    // Setting up SFX path.\n    let shakenSFX = game.settings.get(\n        'swim', 'shakenSFX');\n\n    let bennies;\n    let bv;\n\n    async function rollUnshake() {\n\n        const edgeNames = ['combat reflexes', 'demon', 'undead', 'construct', 'undead (harrowed)'];\n        const actorAlias = speaker.alias;\n        // ROLL SPIRIT AND CHECK COMBAT REFLEXES\n        const r = await token.actor.rollAttribute('spirit');\n        const edges = token.actor.data.items.filter(function (item) {\n            return edgeNames.includes(item.name.toLowerCase()) && (item.type === \"edge\" || item.type === \"ability\");\n        });\n        let rollWithEdge = r.total;\n        let edgeText = \"\";\n        for (let edge of edges) {\n            rollWithEdge += 2;\n            edgeText += `<br/><i>+ ${edge.name}</i>`;\n        }\n\n        let chatData = `${actorAlias} rolled <span style=\"font-size:150%\"> ${rollWithEdge} </span>`;\n        // Checking for a Critical Failure.\n        if (isSame_bool(r.dice) && isSame_numb(r.dice) === 1) {\n            ui.notifications.notify(\"You've rolled a Critical Failure!\");\n            let chatData = `${actorAlias} rolled a <span style=\"font-size:150%\"> Critical Failure! </span>`;\n            ChatMessage.create({ content: chatData });\n        }\n        else {\n            if (rollWithEdge <= 3) {\n                chatData += ` and remains Shaken.`;\n                useBenny();\n            } else if (rollWithEdge >= 4) {\n                chatData += `, is no longer Shaken and may act normally.`;\n                token.actor.update({ \"data.status.isShaken\": false });\n            }\n            chatData += ` ${edgeText}`;\n        }\n        ChatMessage.create({ content: chatData });\n    }\n\n    // Functions to determine a critical failure. This one checks if all dice rolls are the same.\n    function isSame_bool(d = []) {\n        return d.reduce((c, a, i) => {\n            if (i === 0) return true;\n            return c && a.total === d[i - 1].total;\n        }, true);\n    }\n\n    // Functions to determine a critical failure. This one checks what the number of the \"same\" was.\n    function isSame_numb(d = []) {\n        return d.reduce((c, a, i) => {\n            if (i === 0 || d[i - 1].total === a.total) return a.total;\n            return null;\n        }, 0);\n    }\n\n    function useBenny() {\n        bv = checkBennies();\n        if (bv > 0) {\n            new Dialog({\n                title: 'Spend a Benny?',\n                content: `Do you want to spend a Benny to act immediately? (You have ${bv} Bennies left.)`,\n                buttons: {\n                    one: {\n                        label: \"Yes.\",\n                        callback: (html) => {\n                            spendBenny();\n                            token.actor.update({ \"data.status.isShaken\": false });\n                        }\n                    },\n                    two: {\n                        label: \"No.\",\n                        callback: (html) => { return; },\n                    }\n                },\n                default: \"one\"\n            }).render(true)\n        }\n        else {\n            return;\n        }\n    }\n\n    // Check for Bennies\n    function checkBennies() {\n        bennies = token.actor.data.data.bennies.value;\n\n        // Non GM token has <1 bennie OR GM user AND selected token has <1 benny\n        if ((!game.user.isGM && bennies < 1) || (game.user.isGM && bennies < 1 && game.user.getFlag(\"swade\", \"bennies\") < 1)) {\n            ui.notifications.error(\"You have no more bennies left.\");\n        }\n        if (game.user.isGM) {\n            bv = bennies + game.user.getFlag(\"swade\", \"bennies\");\n        }\n        else {\n            bv = bennies;\n        }\n        return bv;\n    }\n\n    // Spend Benny function\n    async function spendBenny() {\n        bennies = token.actor.data.data.bennies.value;\n        //Subtract the spend, use GM benny if user is GM and token has no more bennies left or spend token benny if user is player and/or token has bennies left.\n        if (game.user.isGM && bennies < 1) {\n            game.user.setFlag(\"swade\", \"bennies\", game.user.getFlag(\"swade\", \"bennies\") - 1)\n        } else {\n            token.actor.update({\n                \"data.bennies.value\": bennies - 1,\n            })\n        }\n\n        //Show the Benny Flip\n        if (game.dice3d) {\n            game.dice3d.showForRoll(new Roll(\"1dB\").roll(), game.user, true, null, false);\n        }\n\n        //Chat Message to let the everyone know a benny was spent\n        ChatMessage.create({\n            user: game.user._id,\n            content: `<p><img style=\"border: none;\" src=\"${bennyImage}\"\" width=\"25\" height=\"25\" /> ${game.user.name} spent a Benny and ${token.name} may act normally now.</p>`,\n        });\n    }\n\n    if (token.actor.data.data.status.isShaken === true) {\n        rollUnshake()\n    } else if (token) {\n        token.actor.update({ \"data.status.isShaken\": true })\n        if (shakenSFX) {\n            AudioHelper.play({ src: `${shakenSFX}` }, true);\n        }\n    }\n    /// v.3.3.4 Original code by Shteff, altered by Forien and SalieriC#8263, thanks to Spacemandev for the help as well. Fixed by hirumatto.\n}","author":"wpWSO3unowg8siJN","img":"modules/swim/assets/icons/status_markers/0-Shaken.png","actorIds":[]}
{"_id":"mtxtj7LJqhu94m8H","name":"Unstun","permission":{"default":0,"wpWSO3unowg8siJN":3},"type":"script","flags":{"combat-utility-belt":{"macroTrigger":""},"core":{"sourceId":"Macro.5XICveYBi2K3XduI"}},"scope":"global","command":"//!DOESN'T REROLL ON BENNY; USES UNSHAKE CODE INSTEAD!\nmain();\n\nasync function main() {\n  // No Token is Selected\n  if (!token || canvas.tokens.controlled.length > 1) {\n    ui.notifications.error(\"Please select a single token first.\");\n    return;\n  }\n\n  // Setting up the prone condition image path\n  let proneIconPath = game.settings.get(\n    'swim', 'proneIMG');\n  // Setting up SFX path.\n  let stunSFX = game.settings.get(\n    'swim', 'stunSFX');\n\n  // Checking for SWADE Spices & Flavours and setting up the Benny image.\n  let bennyImage = \"icons/commodities/currency/coin-embossed-octopus-gold.webp\";\n  if (game.modules.get(\"swade-spices\")?.active) {\n    let benny_Back = game.settings.get(\n      'swade-spices', 'bennyBack');\n    if (benny_Back) {\n      bennyImage = benny_Back;\n    }\n  }\n\n  let bennies;\n  let bv;\n\n  async function rollUnstun() {\n\n    const edgeNames = ['combat reflexes'];\n    const actorAlias = speaker.alias;\n    // ROLL VIGOR AND CHECK COMBAT REFLEXES\n    const r = await token.actor.rollAttribute('vigor');\n    const edges = token.actor.data.items.filter(function (item) {\n      return edgeNames.includes(item.name.toLowerCase()) && (item.type === \"edge\" || item.type === \"ability\");\n    });\n    let rollWithEdge = r.total;\n    let edgeText = \"\";\n    for (let edge of edges) {\n      rollWithEdge += 2;\n      edgeText += `<br/><i>+ ${edge.name}</i>`;\n    }\n\n    let chatData = `${actorAlias} rolled <span style=\"font-size:150%\"> ${rollWithEdge} </span>`;\n    // Checking for a Critical Failure.\n    if (isSame_bool(r.dice) && isSame_numb(r.dice) === 1) {\n      ui.notifications.notify(\"You've rolled a Critical Failure!\");\n      let chatData = `${actorAlias} rolled a <span style=\"font-size:150%\"> Critical Failure! </span>`;\n      ChatMessage.create({ content: chatData });\n    }\n    else {\n      if (rollWithEdge > 3 && rollWithEdge <= 7) {\n        chatData += ` and is no longer Stunned but remains Vulnerable until end of next turn.`;\n        token.actor.update({ \"data.status.isVulnerable\": true });\n        token.actor.update({ \"data.status.isStunned\": false });\n        useBenny();\n      } else if (rollWithEdge >= 8) {\n        chatData += `, is no longer Stunned and looses Vulnerable after the turn.`;\n        token.actor.update({ \"data.status.isDistracted\": false });\n        token.actor.update({ \"data.status.isStunned\": false });\n        token.actor.update({ \"data.status.isVulnerable\": false });\n        if (token.data.effects.includes(`${proneIconPath}`)) {\n          token.toggleEffect(`${proneIconPath}`)\n        };\n      } else {\n        chatData += ` and remains Stunned.`;\n        useBenny();\n      }\n      chatData += ` ${edgeText}`;\n    }\n    ChatMessage.create({ content: chatData });\n  }\n\n  // Functions to determine a critical failure. This one checks if all dice rolls are the same.\n  function isSame_bool(d = []) {\n    return d.reduce((c, a, i) => {\n      if (i === 0) return true;\n      return c && a.total === d[i - 1].total;\n    }, true);\n  }\n\n  // Functions to determine a critical failure. This one checks what the number of the \"same\" was.\n  function isSame_numb(d = []) {\n    return d.reduce((c, a, i) => {\n      if (i === 0 || d[i - 1].total === a.total) return a.total;\n      return null;\n    }, 0);\n  }\n\n  function useBenny() {\n    bv = checkBennies();\n    if (bv > 0) {\n      new Dialog({\n        title: 'Spend a Benny?',\n        content: `Do you want to spend a Benny to reroll? (You have ${bv} Bennies left.)`,\n        buttons: {\n          one: {\n            label: \"Yes.\",\n            callback: (html) => {\n              spendBenny();\n              rollUnstun();\n            }\n          },\n          two: {\n            label: \"No.\",\n            callback: (html) => { return; },\n          }\n        },\n        default: \"one\"\n      }).render(true)\n    }\n    else {\n      return;\n    }\n  }\n\n  // Check for Bennies\n  function checkBennies() {\n    bennies = token.actor.data.data.bennies.value;\n\n    // Non GM token has <1 bennie OR GM user AND selected token has <1 benny\n    if ((!game.user.isGM && bennies < 1) || (game.user.isGM && bennies < 1 && game.user.getFlag(\"swade\", \"bennies\") < 1)) {\n      ui.notifications.error(\"You have no more bennies left.\");\n    }\n    if (game.user.isGM) {\n      bv = bennies + game.user.getFlag(\"swade\", \"bennies\");\n    }\n    else {\n      bv = bennies;\n    }\n    return bv;\n  }\n\n  // Spend Benny function\n  async function spendBenny() {\n    bennies = token.actor.data.data.bennies.value;\n    //Subtract the spend, use GM benny if user is GM and token has no more bennies left or spend token benny if user is player and/or token has bennies left.\n    if (game.user.isGM && bennies < 1) {\n      game.user.setFlag(\"swade\", \"bennies\", game.user.getFlag(\"swade\", \"bennies\") - 1)\n    } else {\n      token.actor.update({\n        \"data.bennies.value\": bennies - 1,\n      })\n    }\n\n    //Show the Benny Flip\n    if (game.dice3d) {\n      game.dice3d.showForRoll(new Roll(\"1dB\").roll(), game.user, true, null, false);\n    }\n\n    //Chat Message to let the everyone know a benny was spent\n    ChatMessage.create({\n      user: game.user._id,\n      content: `<p><img style=\"border: none;\" src=\"${bennyImage}\"\" width=\"25\" height=\"25\" /> ${game.user.name} spent a Benny for ${token.name}.</p>`,\n    });\n  }\n\n  if (token.actor.data.data.status.isStunned === true) {\n    rollUnstun()\n  } else if (token) {\n    if (token.actor.data.data.status.isStunned === false) {\n      token.actor.update({ \"data.status.isStunned\": true });\n    };\n\n    if (!token.data.effects.includes(`${proneIconPath}`)) {\n      token.toggleEffect(`${proneIconPath}`)\n    };\n    token.actor.update({ \"data.status.isDistracted\": true });\n    token.actor.update({ \"data.status.isVulnerable\": true });\n    if (stunSFX) {\n      AudioHelper.play({ src: `${stunSFX}` }, true);\n    }\n  }\n  // v.3.2.3 Made by SalieriC#8263 using original Code from Shteff.\n}","author":"wpWSO3unowg8siJN","img":"modules/swim/assets/icons/status_markers/2-Stunned.png","actorIds":[]}
{"_id":"pVeocq78iLEvMRNU","name":"Power Point Management","permission":{"default":0,"wpWSO3unowg8siJN":3},"type":"script","flags":{"combat-utility-belt":{"macroTrigger":""},"core":{"sourceId":"Macro.ETeZuCGyTERwAF0N"}},"scope":"global","command":"main();\n\nfunction main() {\n    // Check if a token is selected.\n    if ((!token || canvas.tokens.controlled.length > 1)) {\n        ui.notifications.error(\"Please select a single token first.\");\n        return;\n    }\n\n    for (let token of canvas.tokens.controlled) {\n        let ppv = token.actor.data.data.powerPoints.value;\n        const ppm = token.actor.data.data.powerPoints.max;\n        let bv;\n        let bennies;\n        const fv = token.actor.data.data.fatigue.value;\n        const fm = token.actor.data.data.fatigue.max;\n        const wv = token.actor.data.data.wounds.value;\n        const wm = token.actor.data.data.wounds.max;\n        const sDrain = token.actor.data.items.find(function (item) {\n            return item.name.toLowerCase() === \"soul drain\" && item.type === \"edge\";\n        });\n        const wBlood = token.actor.data.items.find(function (item) {\n            return item.name.toLowerCase() === \"whateley blood\" && item.type === \"edge\";\n        });\n\n        //Set up\n        let bennyImage = \"icons/commodities/currency/coin-embossed-octopus-gold.webp\";\n        if (game.modules.get(\"swade-spices\")?.active) {\n            let benny_Back = game.settings.get(\n                'swade-spices', 'bennyBack');\n            if (benny_Back) {\n                bennyImage = benny_Back;\n            }\n        }\n        let woundedSFX = game.settings.get(\n            'swim', 'woundedSFX');\n        let incapSFX = game.settings.get(\n            'swim', 'incapSFX');\n        let fatiguedSFX = game.settings.get(\n            'swim', 'fatiguedSFX');\n\n        // Define Playlist to draw sound fx from: Replace \"Magic Effects\" with the name of the desired playlist.\n        let myOptions = '<option value=\"placeHolderThatDoesNothingAtAll\">No Sound</option>'\n        let playListName = \"Magic Effects\"\n        let songs = game.playlists.getName(playListName).data.sounds;\n        for (let song of songs) {\n            myOptions += `<option value=\"${song.path}\">${song.name}</option>`;\n        }\n\n        let buttons = {\n            one: {\n                label: \"Spend PP\",\n                callback: (html) => {\n                    //Button 1: Spend Power Point(s) (uses a number given that reduces data.powerPoints.value (number field)) but can't be lower than 0.\n                    let number = Number(html.find(\"#num\")[0].value);\n                    let newPP = ppv - number\n                    if (newPP < 0) {\n                        ui.notifications.notify(\"You have insufficient Power Points.\")\n                    }\n                    else {\n                        token.actor.update({ \"data.powerPoints.value\": newPP });\n                        let songPath = html.find(\"[name=songname]\")[0].value;\n                        if (songPath !== \"placeHolderThatDoesNothingAtAll\") {\n                            AudioHelper.play({ src: songPath }, true);\n                        }\n\n                        ChatMessage.create({\n                            speaker: {\n                                alias: token.name\n                            },\n                            content: `${token.name} spends ${number} Power Point(s) and has <b>${newPP}</b> left.`\n                        })\n                    }\n                }\n            },\n            two: {\n                label: \"Recharge PP\",\n                callback: (html) => {\n                    //Button 2: Recharge Power Points (uses a number given that increases the data.powerPoints.value a like amount but does not increase it above the number given in data.powerPoints.max (number field))\n                    let number = Number(html.find(\"#num\")[0].value);\n                    let newPP = ppv + number\n                    if (newPP > ppm) {\n                        let actualPP = ppm - ppv;\n                        token.actor.update({ \"data.powerPoints.value\": ppm });\n                        ChatMessage.create({\n                            speaker: {\n                                alias: token.name\n                            },\n                            content: `${token.name} recharges ${actualPP} Power Point(s) and hits the maximum of ${ppm} (overflow prevented).`\n                        })\n                    }\n                    else {\n                        token.actor.update({ \"data.powerPoints.value\": newPP });\n                        ChatMessage.create({\n                            speaker: {\n                                alias: token.name\n                            },\n                            content: `${token.name} recharges ${number} Power Point(s) and now has ${newPP}.`\n                        })\n                    }\n                }\n            },\n            three: {\n                label: \"Benny Recharge\",\n                callback: () => {\n                    //Button 3: Benny Recharge (spends a benny and increases the data.powerPoints.value by 5 but does not increase it above the number given in data.powerPoints.max)\n                    bv = checkBennies();\n                    if (bv < 1) {\n                        return;\n                    }\n                    else {\n                        let newPP = ppv + 5\n                        if (newPP > ppm) {\n                            let actualPP = ppm - ppv;\n                            token.actor.update({ \"data.powerPoints.value\": ppm });\n                            ChatMessage.create({\n                                speaker: {\n                                    alias: token.name\n                                },\n                                content: `<p><img style=\"border: none;\" src=\"${bennyImage}\"\" width=\"25\" height=\"25\" /> ${token.name} recharges ${actualPP} Power Point(s) by spending a Benny and hits the maximum of ${ppm} (overflow prevented).</p>`\n                            })\n                        }\n                        else {\n                            token.actor.update({ \"data.powerPoints.value\": newPP });\n                            ChatMessage.create({\n                                speaker: {\n                                    alias: token.name\n                                },\n                                content: `<p><img style=\"border: none;\" src=\"${bennyImage}\"\" width=\"25\" height=\"25\" /> ${token.name} recharges 5 Power Point(s) using a Benny and now has ${newPP}.</p>`\n                            })\n                        }\n                        spendBenny();\n                    }\n                }\n            },\n        };\n        if (sDrain) buttons[\"four\"] = {\n            label: \"Soul Drain\",\n            callback: () => {\n                //Button 4: Soul Drain (increases data.fatigue.value by 1 and increases the data.powerPoints.value by 5 but does not increase it above the number given in data.powerPoints.max)\n                let newFV = fv + 1\n                if (newFV > fm) {\n                    ui.notifications.notify(\"You cannot exceed your maximum Fatigue using Soul Drain.\")\n                }\n                else {\n                    let newPP = ppv + 5\n                    if (newPP > ppm) {\n                        let actualPP = ppm - ppv;\n                        token.actor.update({ \"data.powerPoints.value\": ppm });\n                        token.actor.update({ \"data.fatigue.value\": fv + 1 });\n                        ChatMessage.create({\n                            speaker: {\n                                alias: token.name\n                            },\n                            content: `${token.name} recharges ${actualPP} Power Point(s) using Soul Drain by causing Fatigue and hits the maximum of ${ppm} (overflow prevented).`\n                        })\n                    }\n                    else {\n                        token.actor.update({ \"data.powerPoints.value\": newPP });\n                        token.actor.update({ \"data.fatigue.value\": fv + 1 });\n                        ChatMessage.create({\n                            speaker: {\n                                alias: token.name\n                            },\n                            content: `${token.name} recharges 5 Power Point(s) using Soul Drain by causing Fatigue and now has ${newPP}.`\n                        })\n                    }\n                    if (fatiguedSFX) {\n                        AudioHelper.play({ src: `${fatiguedSFX}` }, true);\n                    }\n                }\n            },\n        };\n        if (wBlood) buttons[\"five\"] = {\n            label: \"Whateley Blood\",\n            callback: () => {\n                //Button 5: Whateley Blood (increases data.fatigue.value by 1 and increases the data.powerPoints.value by 5 or 10 for a wound; but does not increase it above the number given in data.powerPoints.max)\n                new Dialog({\n                    title: `Whateley Blood`,\n                    buttons: {\n                        wOne: {\n                            label: \"Fatigue (5 PP)\",\n                            callback: () => {\n                                let newFV = fv + 1\n                                if (newFV > fm) {\n                                    let newPP = ppv + 5\n                                    if (newPP > ppm) {\n                                        token.actor.update({ \"data.powerPoints.value\": ppm });\n                                        let actualPP = ppm - ppv;\n                                        let hasAlive = false;\n                                        for (let e of canvas.tokens.controlled) {\n                                            if (!e.getFlag(\"healthEstimate\", \"dead\")) {\n                                                hasAlive = true;\n                                                break\n                                            }\n                                        }\n                                        for (let e of canvas.tokens.controlled) {\n                                            e.setFlag(\"healthEstimate\", \"dead\", hasAlive)\n                                            game.cub.addCondition(\"Incapacitated\")\n                                            ui.notifications.info(\"Marked as dead\");\n                                        };\n                                        ChatMessage.create({\n                                            speaker: {\n                                                alias: token.name\n                                            },\n                                            content: `${token.name} recharges ${actualPP} Power Point(s) using Whateley Blood by causing Fatigue, hits his maximum of ${ppm}, <b>but incapacitated himself in the process</b> (overflow prevented).`\n                                        })\n                                    }\n                                    else {\n                                        token.actor.update({ \"data.powerPoints.value\": newPP });\n                                        let hasAlive = false;\n                                        for (let e of canvas.tokens.controlled) {\n                                            if (!e.getFlag(\"healthEstimate\", \"dead\")) {\n                                                hasAlive = true;\n                                                break\n                                            }\n                                        }\n                                        for (let e of canvas.tokens.controlled) {\n                                            e.setFlag(\"healthEstimate\", \"dead\", hasAlive)\n                                            game.cub.addCondition(\"Incapacitated\")\n                                            ui.notifications.info(\"Marked as dead.\");\n                                        };\n                                        ChatMessage.create({\n                                            speaker: {\n                                                alias: token.name\n                                            },\n                                            content: `${token.name} recharges 5 Power Point(s) using Whateley Blood by causing Fatigue, now has ${newPP}, <b>but incapacitated himself in the process</b>.`\n                                        })\n                                    }\n                                    if (incapSFX) {\n                                        AudioHelper.play({ src: `${incapSFX}` }, true);\n                                    }\n                                }\n                                else {\n                                    let newPP = ppv + 5\n                                    if (newPP > ppm) {\n                                        let actualPP = ppm - ppv;\n                                        token.actor.update({ \"data.powerPoints.value\": ppm });\n                                        token.actor.update({ \"data.fatigue.value\": fv + 1 });\n                                        ChatMessage.create({\n                                            speaker: {\n                                                alias: token.name\n                                            },\n                                            content: `${token.name} recharges ${actualPP} Power Point(s) using Whateley Blood by causing Fatigue and hits the maximum ${ppm} (overflow prevented).`\n                                        })\n                                    }\n                                    else {\n                                        token.actor.update({ \"data.powerPoints.value\": newPP });\n                                        token.actor.update({ \"data.fatigue.value\": fv + 1 });\n                                        ChatMessage.create({\n                                            speaker: {\n                                                alias: token.name\n                                            },\n                                            content: `${token.name} recharges 5 Power Point(s) using Whateley Blood by causing Fatigue and now has ${newPP}.`\n                                        })\n                                    }\n                                    if (fatiguedSFX) {\n                                        AudioHelper.play({ src: `${fatiguedSFX}` }, true);\n                                    }\n                                }\n                            },\n                        },\n                        wTwo: {\n                            label: \"Wound (10 PP)\",\n                            callback: () => {\n                                let newWV = wv + 1\n                                if (newWV > wm) {\n                                    let newPP = ppv + 10\n                                    if (newPP > ppm) {\n                                        let actualPP = ppm - ppv;\n                                        token.actor.update({ \"data.powerPoints.value\": ppm });\n                                        let hasAlive = false;\n                                        for (let e of canvas.tokens.controlled) {\n                                            if (!e.getFlag(\"healthEstimate\", \"dead\")) {\n                                                hasAlive = true;\n                                                break\n                                            }\n                                        }\n                                        for (let e of canvas.tokens.controlled) {\n                                            e.setFlag(\"healthEstimate\", \"dead\", hasAlive)\n                                            game.cub.addCondition(\"Incapacitated\")\n                                            ui.notifications.info(\"Marked as dead/alive.\");\n                                        };\n                                        ChatMessage.create({\n                                            speaker: {\n                                                alias: token.name\n                                            },\n                                            content: `${token.name} recharges ${actualPP} Power Point(s) using Whateley Blood by causing a Wound, hits the maximum of ${ppm}, <b>but incapacitated himself in the process</b> (overflow prevented).`\n                                        })\n                                    }\n                                    else {\n                                        token.actor.update({ \"data.powerPoints.value\": newPP });\n                                        let hasAlive = false;\n                                        for (let e of canvas.tokens.controlled) {\n                                            if (!e.getFlag(\"healthEstimate\", \"dead\")) {\n                                                hasAlive = true;\n                                                break\n                                            }\n                                        }\n                                        for (let e of canvas.tokens.controlled) {\n                                            e.setFlag(\"healthEstimate\", \"dead\", hasAlive)\n                                            game.cub.addCondition(\"Incapacitated\")\n                                            ui.notifications.info(\"Marked as dead/alive.\");\n                                        };\n                                        ChatMessage.create({\n                                            speaker: {\n                                                alias: token.name\n                                            },\n                                            content: `${token.name} recharges 10 Power Point(s) using Whateley Blood by causing a Wound, now has ${newPP}, <b>but incapacitated himself in the process</b>.`\n                                        })\n                                    }\n                                    if (incapSFX) {\n                                        AudioHelper.play({ src: `${incapSFX}` }, true);\n                                    }\n                                }\n                                else {\n                                    let newPP = ppv + 10\n                                    if (newPP > ppm) {\n                                        let actualPP = ppm - ppv;\n                                        token.actor.update({ \"data.powerPoints.value\": ppm });\n                                        token.actor.update({ \"data.wounds.value\": wv + 1 });\n                                        ChatMessage.create({\n                                            speaker: {\n                                                alias: token.name\n                                            },\n                                            content: `${token.name} recharges ${actualPP} Power Point(s) using Whateley Blood by causing a Wound and hits the maximum of ${ppm} (overflow prevented).`\n                                        })\n                                    }\n                                    else {\n                                        token.actor.update({ \"data.powerPoints.value\": newPP });\n                                        token.actor.update({ \"data.wounds.value\": wv + 1 });\n                                        ChatMessage.create({\n                                            speaker: {\n                                                alias: token.name\n                                            },\n                                            content: `${token.name} recharges 10 Power Point(s) using Whateley Blood by causing a Wound and now has ${newPP}.`\n                                        })\n                                    }\n                                    if (woundedSFX) {\n                                        AudioHelper.play({ src: `${woundedSFX}` }, true);\n                                    }\n                                }\n                            },\n                        }\n                    }\n                }).render(true)\n            }\n        };\n\n        // Check for Bennies\n        function checkBennies() {\n            bennies = token.actor.data.data.bennies.value;\n\n            // Non GM token has <1 bennie OR GM user AND selected token has <1 benny\n            if ((!game.user.isGM && bennies < 1) || (game.user.isGM && bennies < 1 && game.user.getFlag(\"swade\", \"bennies\") < 1)) {\n                ui.notifications.error(\"You have no more bennies left.\");\n            }\n            if (game.user.isGM) {\n                bv = bennies + game.user.getFlag(\"swade\", \"bennies\");\n            }\n            else {\n                bv = bennies;\n            }\n            return bv;\n        }\n\n        // Spend Benny function\n        async function spendBenny() {\n            bennies = token.actor.data.data.bennies.value;\n            //Subtract the spend, use GM benny if user is GM and token has no more bennies left or spend token benny if user is player and/or token has bennies left.\n            if (game.user.isGM && bennies < 1) {\n                game.user.setFlag(\"swade\", \"bennies\", game.user.getFlag(\"swade\", \"bennies\") - 1)\n            } else {\n                token.actor.update({\n                    \"data.bennies.value\": bennies - 1,\n                })\n            }\n\n            //Show the Benny Flip\n            if (game.dice3d) {\n                game.dice3d.showForRoll(new Roll(\"1dB\").roll(), game.user, true, null, false);\n            }\n        }\n\n        new Dialog({\n            title: 'Power Point Management',\n            content: `<form>\n            <p>You currently have <b>${ppv}/${ppm}</b> Power Points.</p>\n            <div class=\"form-group\">\n                <label for=\"num\">Amount of Power Points: </label>\n                <input id=\"num\" name=\"num\" type=\"number\" min=\"0\" value=\"5\" onClick=\"this.select();\"></input>\n            </div>\n            <div>\n            <label for=\"sogname\">Sound FX: </label>\n            <select name=\"songname\">${myOptions}</select>\n            </div>\n        </form>`,\n            buttons: buttons,\n            default: \"one\",\n            render: ([dialogContent]) => {\n                dialogContent.querySelector(`input[name=\"num\"`).focus();\n                dialogContent.querySelector(`input[name=\"num\"`).select();\n            },\n        }).render(true)\n    }\n    // v4.3.2 - Made by SalieriC#8263; with a ton of help from Kandashi (He/Him)#6698, thank you so much. =) Also thank you Enrahim#5273 and Freeze#2689 for helping me with the conditional buttons and Freeze again for the sound. Thx eXaminator#0079 for the option to have no sound.\n}","author":"wpWSO3unowg8siJN","img":"icons/tools/laboratory/vials-blue-pink.webp","actorIds":[]}
{"name":"Shuffle Action Deck","permission":{"default":0,"wpWSO3unowg8siJN":3},"type":"script","flags":{"combat-utility-belt":{"macroTrigger":""},"furnace":{"runAsGM":false},"exportSource":{"world":"savage-worlds-50-fatoms","system":"swade","coreVersion":"0.7.7","systemVersion":"0.14.1"},"core":{"sourceId":"Macro.yyHpyfnck6yL9pmK"}},"scope":"global","command":"const table = game.tables.entities.find(t => t.name === \"Action Cards\");\ntable.reset();\nui.notifications.info(\"Action Deck shuffled.\");\nAudioHelper.play({ src: `systems/swade/assets/card-flip.wav` }, true);","author":"wpWSO3unowg8siJN","img":"systems/swade/assets/ui/wildcard.svg","actorIds":[],"_id":"pZxQv6ZOUDsj3ocg"}
{"name":"Deviation","permission":{"default":0,"wpWSO3unowg8siJN":3},"type":"script","flags":{"combat-utility-belt":{"macroTrigger":""},"core":{"sourceId":"Macro.kqNehEXmaItvZ0ZU"}},"scope":"global","command":"const chatimage = \"https://raw.githubusercontent.com/brunocalado/mestre-digital/master/Foundry%20VTT/Macros/Savage%20Worlds/icons/clock.webp\";\n\n/* Deviation p99 SWADE\nIf a blast template misses, it deviates 1d6\nfor thrown weapons (such as grenades) and\n2d6 for fired projectiles. Multiply by 2 if the\nattack was made at Medium Range, 3 if Long,\nand 4 for Extreme.\n\nNext roll a d12 and read it like a clock\nfacing to determine the direction the missile\ndeviates. A weapon can never deviate more\nthan half the distance to the original target\n(that keeps it from going behind the thrower).\n\nsource: https://raw.githubusercontent.com/brunocalado/mestre-digital/master/Foundry%20VTT/Macros/Savage%20Worlds/Deviation.js; altered by SalieriC.\nicon: icons/weapons/artillery/cannon-engraved-gold.webp\n*/\n\nlet coreRules = false;\nif (game.modules.get(\"swade-core-rules\")?.active) {coreRules = true;}\n\ngetRequirements();\n\nfunction getRequirements() {\n  let template = `\n  <h2>Weapon Type</h2>\n  <table style=\"width:100%\">\n  <tr>\n    <td><input type=\"radio\" id=\"thrown\" name=\"weapontype\" value=\"thrown\"><label for=\"thrown\">Thrown weapon</label></td>\n    <td><input type=\"radio\" id=\"projectile\" name=\"weapontype\" value=\"projectile\" checked=\"checked><label for=\"projectile\">Projectile</label></td>    \n  </tr>\n  </table>  \n  <h2>Range</h2>\n  <table style=\"width:100%\">\n  <tr>\n    <td><input type=\"radio\" id=\"short\" name=\"range\" value=\"short\" checked=\"checked><label for=\"thrown\">Short</label></td>\n    <td><input type=\"radio\" id=\"medium\" name=\"range\" value=\"medium\"><label for=\"projectile\">Medium</label></td>    \n    <td><input type=\"radio\" id=\"long\" name=\"range\" value=\"long\"><label for=\"projectile\">Long</label></td>    \n    <td><input type=\"radio\" id=\"extreme\" name=\"range\" value=\"extreme\"><label for=\"projectile\">Extreme</label></td>    \n  </tr>\n  </table>    \n  `;\n  new Dialog({\n    title: \"Deviation\",\n    content: template,\n    buttons: {\n      ok: {\n        label: \"Go!\",\n        callback: async (html) => {\n          rollForIt(html);\n        },\n      }\n    },\n  }).render(true);\n}\n\nfunction rollForIt(html) {\n  const weapontype=html.find('input[name=\"weapontype\"]:checked').val();\n  const range=html.find('input[name=\"range\"]:checked').val();\n  let deviation;\n  \n  if (weapontype=='thrown') {\n    deviation = diceRoll('1d6', range);\n  } else {\n    deviation = diceRoll('2d6', range);\n  }\n}\n\nfunction diceRoll(die, range) {\n  const rangeMultiplier = rangeCheck(range);\n  let direction = new Roll('1d12').roll();\n  let roll = new Roll(die).roll();\n  let message = `<h2>Deviation</h2>`;\n  if (coreRules === true) {message = `<div class=\"swade-core\"><h2>@Compendium[swade-core-rules.swade-rules.xxEcWExtn36PPxg0]{Deviation}</h2>`;}\n  message += `<p>Move the blast <b>${roll.total*rangeMultiplier}\"</b> to <b style=\"color:red\">${direction.total}</b> O'Clock.</p>`;\n  if (directionCheck(direction.total)) {\n    message += `<p><b style=\"color:red\">A weapon can never deviate more than half the distance to the original target (that keeps it from going behind the thrower).</b></p>`;\n  }\n  message += `<p style=\"text-align:center\"><img style=\"vertical-align:middle; border: none;\" src=${chatimage} width=\"200\" height=\"200\"><p>`;\n  if (coreRules === true) {message += `</div>`}\n\n  let tempChatData = {\n    type: CHAT_MESSAGE_TYPES.ROLL,\n    roll: roll,\n    rollMode: game.settings.get(\"core\", \"rollMode\"),\n    content: message\n  };     \n  ChatMessage.create(tempChatData);  \n  return roll.total;\n}\n\nfunction rangeCheck(range) {\n  if (range=='short') {\n    return 1;\n  } else if (range=='medium') {\n    return 2;\n  } else if (range=='long') {\n    return 3;\n  } else if (range=='extreme') {\n    return 4;\n  }\n}\n\nfunction directionCheck(direction) {\n  console.log(direction);\n  if (direction==4 || direction==5 || direction==6 || direction==7 || direction==8) {\n    return true\n  } else {\n    return false\n  } \n  // v. 1.0.0 - Original code by brunocalado, modified by SalieriC#8263.\n  // Image source: https://freesvg.org/analogue-clock-vector-graphics\n}","author":"wpWSO3unowg8siJN","img":"icons/weapons/thrown/dynamite-simple-brown.webp","actorIds":[],"_id":"tniGXuJmELBtXcXq"}
{"_id":"vIEcQWeP08RgMpq4","name":"Personal Health Centre","permission":{"default":0,"wpWSO3unowg8siJN":3},"type":"script","flags":{"combat-utility-belt":{"macroTrigger":""},"core":{"sourceId":"Macro.SjOf7Sp0D4ljIWfQ"}},"scope":"global","command":"main();\n\nfunction main() {\n    // Check if a token is selected.\n    if ((!token || canvas.tokens.controlled.length > 1)) {\n        ui.notifications.error(\"Please select a single token first.\");\n        return;\n    }\n    // Checking for SWADE Spices & Flavours and setting up the Benny image.\n    let bennyImage = \"icons/commodities/currency/coin-embossed-octopus-gold.webp\";\n    if (game.modules.get(\"swade-spices\")?.active) {\n        let benny_Back = game.settings.get(\n            'swade-spices', 'bennyBack');\n        if (benny_Back) {\n            bennyImage = benny_Back;\n        }\n    }\n    // Setting SFX\n    let woundedSFX = game.settings.get(\n        'swim', 'woundedSFX');\n    let incapSFX = game.settings.get(\n        'swim', 'incapSFX');\n    let healSFX = game.settings.get(\n        'swim', 'healSFX');\n    let looseFatigueSFX = game.settings.get(\n        'swim', 'looseFatigueSFX');\n    let potionSFX = game.settings.get(\n        'swim', 'potionSFX');\n\n    // Declairing variables and constants.\n    const wv = token.actor.data.data.wounds.value;\n    const wm = token.actor.data.data.wounds.max;\n    const fv = token.actor.data.data.fatigue.value;\n    const fm = token.actor.data.data.fatigue.max;\n    //Checking for Edges (and Special/Racial Abilities)\n    let natHeal_time = game.settings.get(\n        'swim', 'natHeal_time');\n    const fastHealer = token.actor.data.items.find(function (item) {\n        return ((item.name.toLowerCase() === \"fast healer\") && item.type === \"edge\");\n    });\n    if (fastHealer) { natHeal_time = \"three days\" };\n    const reg_slow = token.actor.data.items.find(function (item) {\n        return ((item.name.toLowerCase() === \"slow regeneration\") && item.type === \"ability\");\n    });\n    if (reg_slow) { natHeal_time = \"day\" };\n    const reg_fast = token.actor.data.items.find(function (item) {\n        return ((item.name.toLowerCase() === \"fast regeneration\") && item.type === \"ability\");\n    });\n    if (reg_fast) { natHeal_time = \"round\" };\n    const elan = token.actor.data.items.find(function (item) {\n        return item.name.toLowerCase() === \"elan\" && item.type === \"edge\";\n    });\n    //Checking for Health Potions\n    const healthPotionOptions = game.settings.get(\n        'swim', 'healthPotionOptions');\n    const healthPotionsSplit = healthPotionOptions.split(', ');\n    const hasHealthPotion = token.actor.data.items.find(function (item) {\n        return (healthPotionsSplit.includes(item.name) && item.type === \"gear\" && item.data.quantity > 0)\n    });\n    //Find owned Health potions.\n    const ownedHealthPotions = healthPotionsSplit.filter(potion => token.actor.data.items.some(item => item.name === potion && item.type === \"gear\" && item.data.quantity > 0));\n    //Set up a list of Health Potions to choose from.\n    let healthPotionList;\n    for (let healthPotion of ownedHealthPotions) {\n        healthPotionList += `<option value=\"${healthPotion}\">${healthPotion}</option>`;\n    }\n\n//Checking for Fatigue Potions\nconst fatiguePotionOptions = game.settings.get(\n    'swim', 'fatiguePotionOptions');\nconst fatiguePotionsSplit = fatiguePotionOptions.split(', ');\nconst hasFatiguePotion = token.actor.data.items.find(function (item) {\n    return (fatiguePotionsSplit.includes(item.name) && item.type === \"gear\" && item.data.quantity > 0)\n});\n//Find owned Fatigue potions.\nconst ownedFatiguePotions = fatiguePotionsSplit.filter(potion => token.actor.data.items.some(item => item.name === potion && item.type === \"gear\" && item.data.quantity > 0));\n//Set up a list of Fatigue Potions to choose from.\nlet fatiguePotionList;\nfor (let fatiguePotion of ownedFatiguePotions) {\n    fatiguePotionList += `<option value=\"${fatiguePotion}\">${fatiguePotion}</option>`;\n}\n\n    let bennies = token.actor.data.data.bennies.value;\n    let bv;\n    bv = checkBennies();\n    let numberWounds;\n    let rounded;\n    let elanBonus;\n    let setWounds;\n    let genericHealWounds;\n    let genericHealFatigue;\n    let buttons_main;\n    let md_text\n\n    // Adjusting buttons and Main Dialogue text\n    if (fv < 1 && wv < 1) {\n        md_text = `<form>\n    <p>You currently neither have any Wounds nor Fatigue. There is nothing for you to do here.</p>\n    </form>`;\n        buttons_main = {\n            one: {\n                label: \"Nevermind...\",\n                callback: (html) => { },\n            }\n        }\n    }\n    else if (fv > 0 && wv < 1 && !hasFatiguePotion) {\n        md_text = `<form>\n    <p>You currently have <b>no</b> Wounds and <b>${fv}/${fm}</b> Fatigue.</p>\n    <p>In general you may remove a Level of Fatigue <b>every hour</b> when resting and the source of your Fatigue is absent. This can be altered depending on the source of Fatigue, so <b>ask your GM</b> if you're allowed to remove your Fatigue now.</p>\n    <p>What you you want to do?</p>\n    </form>`;\n        buttons_main = {\n            one: {\n                label: \"Cure Fatigue\",\n                callback: (html) => {\n                    genericRemoveFatigue();\n                }\n            }\n        }\n    }\n    else if (fv > 0 && wv < 1 && hasFatiguePotion) {\n        md_text = `<form>\n    <p>You currently have <b>no</b> Wounds and <b>${fv}/${fm}</b> Fatigue.</p>\n    <p>In general you may remove a Level of Fatigue <b>every hour</b> when resting and the source of your Fatigue is absent. This can be altered depending on the source of Fatigue, so <b>ask your GM</b> if you're allowed to remove your Fatigue now.</p>\n    <p>You still have a <b>potion that cures Fatigue</b>, you might as well use it (but ask your GM, the source of your Fatigue might not allow it).</p>\n    <p>What you you want to do?</p>\n    </form>`;\n        buttons_main = {\n            one: {\n                label: \"Cure Fatigue\",\n                callback: (html) => {\n                    genericRemoveFatigue();\n                }\n            },\n            two: {\n                label: \"Potion\",\n                callback: (html) => {\n                    useFatiguePotion();\n                }\n            }\n        }\n    }\n    else if (fv < 1 && wv > 0 && !hasHealthPotion) {\n        md_text = `<form>\n    <p>You currently have <b>${wv}/${wm}</b> Wounds, <b>no</b> Fatigue and <b>${bv}</b> Bennies.</p>\n    <p>You may make a Natural Healing roll <b>every ${natHeal_time}</b> unless altered by setting specific circumstances.</p>\n    <p>You may also heal wounds directly (i.e. from the Healing Power). What you you want to do?</p>\n    </form>`;\n        buttons_main = {\n            one: {\n                label: \"Natural Healing\",\n                callback: (html) => {\n                    numberWounds = wv;\n                    rollNatHeal();\n                }\n            },\n            two: {\n                label: \"Direct Healing\",\n                callback: (html) => {\n                    genericRemoveWounds();\n                }\n            }\n        }\n    }\n    else if (fv < 1 && wv > 0 && hasHealthPotion) {\n        md_text = `<form>\n    <p>You currently have <b>${wv}/${wm}</b> Wounds, <b>no</b> Fatigue and <b>${bv}</b> Bennies.</p>\n    <p>You may make a Natural Healing roll <b>every ${natHeal_time}</b> unless altered by setting specific circumstances.</p>\n    <p>You still have <b>Healing potions</b>, you might as well use one of these.</p>\n    <p>You may also heal wounds directly (i.e. from the Healing Power). What you you want to do?</p>\n    </form>`;\n        buttons_main = {\n            one: {\n                label: \"Natural Healing\",\n                callback: (html) => {\n                    numberWounds = wv;\n                    rollNatHeal();\n                }\n            },\n            two: {\n                label: \"Direct Healing\",\n                callback: (html) => {\n                    genericRemoveWounds();\n                }\n            },\n            three: {\n                label: \"Potion\",\n                callback: (html) => {\n                    useHealthPotion();\n                }\n            }\n        }\n    }\n    else if (wv > 0 && fv > 0 && !hasFatiguePotion && !hasHealthPotion) {\n        md_text = `<form>\n    <p>You currently have <b>${wv}/${wm}</b> Wounds, <b>${fv}/${fm}</b> Fatigue and <b>${bv}</b> Bennies.</p>\n    <p>You may make a Natural Healing roll <b>every ${natHeal_time}</b> unless altered by setting specific circumstances.</p>\n    <p>You still have <b>Healing potions</b>, you might as well use one of these.</p>\n    <p>In general you may remove a Level of Fatigue <b>every hour</b> when resting and the source of your Fatigue is absent. This can be altered depending on the source of Fatigue, so <b>ask your GM</b> if you're allowed to remove your Fatigue now.</p>\n    <p>You may also heal wounds directly (i.e. from the Healing Power) or cure Fatigue. What you you want to do?</p>\n    </form>`;\n        buttons_main = {\n            one: {\n                label: \"Natural Healing\",\n                callback: (html) => {\n                    numberWounds = wv;\n                    rollNatHeal();\n                }\n            },\n            two: {\n                label: \"Direct Healing\",\n                callback: (html) => {\n                    genericRemoveWounds();\n                }\n            },\n            four: {\n                label: \"Cure Fatigue\",\n                callback: (html) => {\n                    genericRemoveFatigue();\n                }\n            }\n        }\n    }\n    else if (wv > 0 && fv > 0 && !hasFatiguePotion && hasHealthPotion) {\n        md_text = `<form>\n    <p>You currently have <b>${wv}/${wm}</b> Wounds, <b>${fv}/${fm}</b> Fatigue and <b>${bv}</b> Bennies.</p>\n    <p>You may make a Natural Healing roll <b>every ${natHeal_time}</b> unless altered by setting specific circumstances.</p>\n    <p>You still have <b>Healing potions</b>, you might as well use one of these.</p>\n    <p>In general you may remove a Level of Fatigue <b>every hour</b> when resting and the source of your Fatigue is absent. This can be altered depending on the source of Fatigue, so <b>ask your GM</b> if you're allowed to remove your Fatigue now.</p>\n    <p>You may also heal wounds directly (i.e. from the Healing Power) or cure Fatigue. What you you want to do?</p>\n    </form>`;\n        buttons_main = {\n            one: {\n                label: \"Natural Healing\",\n                callback: (html) => {\n                    numberWounds = wv;\n                    rollNatHeal();\n                }\n            },\n            two: {\n                label: \"Direct Healing\",\n                callback: (html) => {\n                    genericRemoveWounds();\n                }\n            },\n            three: {\n                label: \"Potion (heal)\",\n                callback: (html) => {\n                    useHealthPotion();\n                }\n            },\n            four: {\n                label: \"Cure Fatigue\",\n                callback: (html) => {\n                    genericRemoveFatigue();\n                }\n            },\n        }\n    }\n    else if (wv > 0 && fv > 0 && hasFatiguePotion && !hasHealthPotion) {\n        md_text = `<form>\n    <p>You currently have <b>${wv}/${wm}</b> Wounds, <b>${fv}/${fm}</b> Fatigue and <b>${bv}</b> Bennies.</p>\n    <p>You may make a Natural Healing roll <b>every ${natHeal_time}</b> unless altered by setting specific circumstances.</p>\n    <p>You still have <b>potions that cure Fatigue</b>, you might as well use one of these (but ask your GM, the source of your Fatigue might not allow it).</p>\n    <p>In general you may remove a Level of Fatigue <b>every hour</b> when resting and the source of your Fatigue is absent. This can be altered depending on the source of Fatigue, so <b>ask your GM</b> if you're allowed to remove your Fatigue now.</p>\n    <p>You may also heal wounds directly (i.e. from the Healing Power) or cure Fatigue. What you you want to do?</p>\n    </form>`;\n        buttons_main = {\n            one: {\n                label: \"Natural Healing\",\n                callback: (html) => {\n                    numberWounds = wv;\n                    rollNatHeal();\n                }\n            },\n            two: {\n                label: \"Direct Healing\",\n                callback: (html) => {\n                    genericRemoveWounds();\n                }\n            },\n            three: {\n                label: \"Cure Fatigue\",\n                callback: (html) => {\n                    genericRemoveFatigue();\n                }\n            },\n            four: {\n                label: \"Potion (Fatigue)\",\n                callback: (html) => {\n                    useFatiguePotion();\n                }\n            },\n        }\n    }\n    else if (wv > 0 && fv > 0 && hasFatiguePotion && hasHealthPotion) {\n        md_text = `<form>\n    <p>You currently have <b>${wv}/${wm}</b> Wounds, <b>${fv}/${fm}</b> Fatigue and <b>${bv}</b> Bennies.</p>\n    <p>You may make a Natural Healing roll <b>every ${natHeal_time}</b> unless altered by setting specific circumstances.</p>\n    <p>You still have <b>Health Potions</b> and <b>potions that cure Fatigue</b>, you might as well use one of these (but ask your GM, the source of your Fatigue might not allow it).</p>\n    <p>In general you may remove a Level of Fatigue <b>every hour</b> when resting and the source of your Fatigue is absent. This can be altered depending on the source of Fatigue, so <b>ask your GM</b> if you're allowed to remove your Fatigue now.</p>\n    <p>You may also heal wounds directly (i.e. from the Healing Power) or cure Fatigue. What you you want to do?</p>\n    </form>`;\n        buttons_main = {\n            one: {\n                label: \"Natural Healing\",\n                callback: (html) => {\n                    numberWounds = wv;\n                    rollNatHeal();\n                }\n            },\n            two: {\n                label: \"Direct Healing\",\n                callback: (html) => {\n                    genericRemoveWounds();\n                }\n            },\n            three: {\n                label: \"Potion (heal)\",\n                callback: (html) => {\n                    useHealthPotion();\n                }\n            },\n            four: {\n                label: \"Cure Fatigue\",\n                callback: (html) => {\n                    genericRemoveFatigue();\n                }\n            },\n            five: {\n                label: \"Potion (Fatigue)\",\n                callback: (html) => {\n                    useFatiguePotion();\n                }\n            }\n        }\n    }\n\n    // Check for Bennies\n    function checkBennies() {\n        bennies = token.actor.data.data.bennies.value;\n\n        // Non GM token has <1 bennie OR GM user AND selected token has <1 benny\n        if ((!game.user.isGM && bennies < 1) || (game.user.isGM && bennies < 1 && game.user.getFlag(\"swade\", \"bennies\") < 1)) {\n            ui.notifications.error(\"You have no more bennies left. Wounds will be applied now...\");\n        }\n        if (game.user.isGM) {\n            bv = bennies + game.user.getFlag(\"swade\", \"bennies\");\n        }\n        else {\n            bv = bennies;\n        }\n        return bv;\n    }\n\n    // This is the main function that handles the Vigor roll.\n    async function rollNatHeal() {\n\n        const edgeNames = ['fast healer'];\n        const actorAlias = speaker.alias;\n        // Roll Vigor and check for Fast Healer.\n        const r = await token.actor.rollAttribute('vigor');\n        const edges = token.actor.data.items.filter(function (item) {\n            return edgeNames.includes(item.name.toLowerCase()) && (item.type === \"edge\" || item.type === \"ability\");\n        });\n        let rollWithEdge = r.total;\n        let edgeText = \"\";\n        for (let edge of edges) {\n            rollWithEdge += 2;\n            edgeText += `<br/><i>+ ${edge.name}</i>`;\n        }\n\n        // Apply +2 if Elan is present and if it is a reroll.\n        if (typeof elanBonus === \"number\") {\n            rollWithEdge += 2;\n            edgeText = edgeText + `<br/><i>+ Elan</i>.`;\n        }\n\n        // Roll Vigor including +2 if Fast Healer is present and another +2 if this is a reroll.\n        let chatData = `${actorAlias} rolled <span style=\"font-size:150%\"> ${rollWithEdge} </span>`;\n        rounded = Math.floor(rollWithEdge / 4);\n\n        // Making rounded 0 if it would be negative.\n        if (rounded < 0) {\n            rounded = 0;\n        }\n\n        // Checking for a Critical Failure.\n        if (isSame_bool(r.dice) && isSame_numb(r.dice) === 1) {\n            ui.notifications.notify(\"You've rolled a Critical Failure!\");\n            let chatData = `${actorAlias} rolled a <span style=\"font-size:150%\">Critical Failure!</span> and takes another Wound! See the rules on Natural Healing for details.`;\n            applyWounds();\n            ChatMessage.create({ content: chatData });\n        }\n        else {\n            if (rounded < 1) {\n                bv = checkBennies();\n                chatData += ` and is unable to heal any Wounds.`;\n                if (bv < 1) {\n                    return;\n                }\n                else {\n                    dialogReroll();\n                }\n            } else if ((rounded === 1 && numberWounds > 1) || (rounded === 2 && numberWounds > 2)) {\n                chatData += ` and heals ${rounded} of his ${numberWounds} Wounds.`;\n                if (bv < 1) {\n                    removeWounds();\n                }\n                else {\n                    dialogReroll();\n                };\n            } else if ((rounded > 1 && rounded >= numberWounds && numberWounds < 3) || (rounded === 1 && numberWounds === 1)) {\n                chatData += ` and heals all of his Wounds.`;\n                removeWounds();\n            }\n            chatData += ` ${edgeText}`;\n\n            ChatMessage.create({ content: chatData });\n        }\n    }\n\n    // Functions to determine a critical failure. This one checks if all dice rolls are the same.\n    function isSame_bool(d = []) {\n        return d.reduce((c, a, i) => {\n            if (i === 0) return true;\n            return c && a.total === d[i - 1].total;\n        }, true);\n    }\n\n    // Functions to determine a critical failure. This one checks what the number of the \"same\" was.\n    function isSame_numb(d = []) {\n        return d.reduce((c, a, i) => {\n            if (i === 0 || d[i - 1].total === a.total) return a.total;\n            return null;\n        }, 0);\n    }\n\n    // Spend Benny function\n    async function spendBenny() {\n        bennies = token.actor.data.data.bennies.value;\n        //Subtract the spend, use GM benny if user is GM and token has no more bennies left or spend token benny if user is player and/or token has bennies left.\n        if (game.user.isGM && bennies < 1) {\n            game.user.setFlag(\"swade\", \"bennies\", game.user.getFlag(\"swade\", \"bennies\") - 1)\n        } else {\n            token.actor.update({\n                \"data.bennies.value\": bennies - 1,\n            })\n        }\n\n        //Show the Benny Flip\n        if (game.dice3d) {\n            game.dice3d.showForRoll(new Roll(\"1dB\").roll(), game.user, true, null, false);\n        }\n\n        //Chat Message to let the everyone know a benny was spent\n        ChatMessage.create({\n            user: game.user._id,\n            content: `<p><img style=\"border: none;\" src=\"${bennyImage}\"\" width=\"25\" height=\"25\" /> ${game.user.name} spent a Benny for ${token.name}.</p>`,\n        });\n    }\n\n    // Function containing the reroll Dialogue\n    function dialogReroll() {\n        bv = checkBennies();\n        if (bv > 0) {\n            new Dialog({\n                title: 'Reroll',\n                content: `<form>\n                You've healed <b>${rounded} Wounds</b>.\n                </br>Do you want to reroll your Natural Healing roll (you have <b>${bv} Bennies</b> left)?\n                </form>`,\n                buttons: {\n                    one: {\n                        label: \"Reroll\",\n                        callback: (html) => {\n                            spendBenny();\n                            if (!!elan) {\n                                elanBonus = 2;\n                            }\n                            rollNatHeal();\n                        }\n                    },\n                    two: {\n                        label: \"No\",\n                        callback: (html) => {\n                            if (rounded < 1) {\n                                ui.notifications.notify(\"As you wish.\");\n                            }\n                            else {\n                                ui.notifications.notify(\"As you wish, Wounds will be removed now.\");\n                            }\n                            removeWounds();\n                        }\n                    }\n                },\n                default: \"one\"\n            }).render(true);\n        }\n        else {\n            ui.notifications.notify(\"You have no more bennies.\");\n            removeWounds();\n        }\n    }\n\n    // Main Dialogue\n    new Dialog({\n        title: 'Personal Health Centre',\n        content: md_text,\n        buttons: buttons_main,\n        default: \"one\",\n    }).render(true);\n\n    function removeWounds() {\n        if (genericHealWounds) {\n            if (genericHealWounds > wv) {\n                genericHealWounds = wv;\n                ui.notifications.error(`You can't heal more wounds than you have, healing all Wounds instead now...`);\n            }\n            setWounds = wv - genericHealWounds;\n            token.actor.update({ \"data.wounds.value\": setWounds });\n            ui.notifications.notify(`${genericHealWounds} Wound(s) healed.`);\n        }\n        else {\n            if (rounded === 1) {\n                setWounds = wv - 1;\n                if (setWounds < 0) {\n                    setWounds = 0;\n                }\n                token.actor.update({ \"data.wounds.value\": setWounds });\n                ui.notifications.notify(\"One Wound healed.\");\n            }\n            if (rounded >= 2) {\n                setWounds = wv - 2;\n                if (setWounds < 0) {\n                    setWounds = 0\n                }\n                token.actor.update({ \"data.wounds.value\": setWounds });\n                ui.notifications.notify(\"Two Wounds healed.\");\n            }\n        }\n        if (healSFX && genericHealWounds > 0 || healSFX && rounded > 0) {\n            AudioHelper.play({ src: `${healSFX}` }, true);\n        }\n    }\n\n    // Healing from a source other than Natural Healing\n    function genericRemoveWounds() {\n        new Dialog({\n            title: 'Direct Healing',\n            content: `<form>\n        <p>You currently have <b>${wv}/${wm}</b>. If you've been healed from a source other than Natural Healing, enter the amount of Wounds below:</p>\n    <div class=\"form-group\">\n        <label for=\"numWounds\">Amount of Wounds: </label>\n        <input id=\"numWounds\" name=\"num\" type=\"number\" min=\"0\" value=\"1\" onClick=\"this.select();\"></input>\n    </div>\n    </form>`,\n            buttons: {\n                one: {\n                    label: \"Heal Wounds\",\n                    callback: (html) => {\n                        genericHealWounds = Number(html.find(\"#numWounds\")[0].value);\n                        removeWounds();\n                    }\n                }\n            },\n            default: \"one\",\n            render: ([dialogContent]) => {\n                dialogContent.querySelector(`input[name=\"num\"`).focus();\n                dialogContent.querySelector(`input[name=\"num\"`).select();\n            },\n        }).render(true);\n    }\n\n    // Healing from a source other than Natural Healing\n    function useHealthPotion() {\n        new Dialog({\n            title: 'Healing Potion',\n            content: `<form>\n        <p>You currently have <b>${wv}/${wm}</b>. If you want to use a healing potion, enter the amount of Wounds it heals and select the desired potion below:</p>\n    <div class=\"form-group\">\n        <label for=\"numWounds\">Amount of Wounds: </label>\n        <input id=\"numWounds\" name=\"num\" type=\"number\" min=\"0\" value=\"1\" onClick=\"this.select();\"></input>\n    </div>\n    <div class=\"form-group\">\n            <label for=\"potionName\">Potion to use: </label>\n            <select name=\"potionName\">${healthPotionList}</select>\n            </div>\n    </form>`,\n            buttons: {\n                one: {\n                    label: \"Use Potion\",\n                    callback: async(html) => {\n                        genericHealWounds = Number(html.find(\"#numWounds\")[0].value);\n                        let selectedPotion = String(html.find(\"[name=potionName]\")[0].value);\n                        let potion_to_update = token.actor.items.find(i => i.name === selectedPotion);\n                        let potion_icon = potion_to_update.data.img;\n                        await token.actor.updateOwnedItem({_id: potion_to_update.id, \"data.quantity\": potion_to_update.data.data.quantity - 1})\n                        if (potion_to_update.data.data.quantity < 1){\n                          potion_to_update.delete();\n                        }\n                        ChatMessage.create({\n                            speaker: {\n                                alias: token.name\n                            },\n                            content: `<img style=\"border: none;\" src=\"${potion_icon}\" alt=\"\" width=\"25\" height=\"25\" /> ${token.name} uses a ${selectedPotion} to heal ${genericHealWounds} wound(s).`\n                        })\n                        if (potionSFX) {\n                            let audioDuration = AudioHelper.play({ src: `${potionSFX}` }, true)._duration;\n                            await wait(audioDuration*1000);\n                        }\n                        removeWounds();\n                    }\n                }\n            },\n            default: \"one\",\n            render: ([dialogContent]) => {\n                dialogContent.querySelector(`input[name=\"num\"`).focus();\n                dialogContent.querySelector(`input[name=\"num\"`).select();\n            },\n        }).render(true);\n    }\n\n    // Healing from a source other than Natural Healing\n    function useFatiguePotion() {\n        new Dialog({\n            title: 'Potion to cure Fatigue',\n            content: `<form>\n        <p>You currently have <b>${fv}/${fm}</b>. If you want to use a potion that cures Fatigue, enter the amount of Fatigue it cures and select the desired potion below:</p>\n    <div class=\"form-group\">\n        <label for=\"numFatigue\">Amount of Fatigue: </label>\n        <input id=\"numFatigue\" name=\"num\" type=\"number\" min=\"0\" value=\"1\" onClick=\"this.select();\"></input>\n    </div>\n    <div class=\"form-group\">\n            <label for=\"potionName\">Potion to use: </label>\n            <select name=\"potionName\">${fatiguePotionList}</select>\n            </div>\n    </form>`,\n            buttons: {\n                one: {\n                    label: \"Use Potion\",\n                    callback: async(html) => {\n                        genericHealFatigue = Number(html.find(\"#numFatigue\")[0].value);\n                        let selectedPotion = String(html.find(\"[name=potionName]\")[0].value);\n                        let potion_to_update = token.actor.items.find(i => i.name === selectedPotion);\n                        let potion_icon = potion_to_update.data.img;\n                        await token.actor.updateOwnedItem({_id: potion_to_update.id, \"data.quantity\": potion_to_update.data.data.quantity - 1})\n                        if (potion_to_update.data.data.quantity < 1){\n                          potion_to_update.delete();\n                        }\n                        ChatMessage.create({\n                            speaker: {\n                                alias: token.name\n                            },\n                            content: `<img style=\"border: none;\" src=\"${potion_icon}\" alt=\"\" width=\"25\" height=\"25\" /> ${token.name} uses a ${selectedPotion} to cure ${genericHealFatigue} level(s) of Fatigue.`\n                        })\n                        if (potionSFX) {\n                            let audioDuration = AudioHelper.play({ src: `${potionSFX}` }, true)._duration;\n                            await wait(audioDuration*1000);\n                        }\n                        RemoveFatigue();\n                    }\n                }\n            },\n            default: \"one\",\n            render: ([dialogContent]) => {\n                dialogContent.querySelector(`input[name=\"num\"`).focus();\n                dialogContent.querySelector(`input[name=\"num\"`).select();\n            },\n        }).render(true);\n    }\n\n    // Removing Fatigue\n    function genericRemoveFatigue() {\n        new Dialog({\n            title: 'Cure Fatigue',\n            content: `<form>\n        <p>You currently have <b>${fv}/${fm}</b> If your Fatigue has been cured or expired, enter the amount of Fatigue below:</p>\n    <div class=\"form-group\">\n        <label for=\"numWounds\">Amount of Fatigue: </label>\n        <input id=\"numFatigue\" name=\"num\" type=\"number\" min=\"0\" value=\"1\" onClick=\"this.select();\"></input>\n    </div>\n    </form>`,\n            buttons: {\n                one: {\n                    label: \"Cure Fatigue\",\n                    callback: async(html) => {\n                        genericHealFatigue = Number(html.find(\"#numFatigue\")[0].value);\n                        RemoveFatigue();\n                        await ChatMessage.create({\n                            speaker: {\n                                alias: token.name\n                            },\n                            content: `${token.name} lost ${genericHealFatigue} Level(s) of Fatigue.`\n                        })\n                    }\n                }\n            },\n            default: \"one\",\n            render: ([dialogContent]) => {\n                dialogContent.querySelector(`input[name=\"num\"`).focus();\n                dialogContent.querySelector(`input[name=\"num\"`).select();\n            },\n        }).render(true);\n    }\n\n    function RemoveFatigue() {\n        if (genericHealFatigue > fv) {\n            genericHealFatigue = fv;\n            ui.notifications.error(`You can't cure more Fatigue than you have, curing all Fatigue instead now...`);\n        }\n        let setFatigue = fv - genericHealFatigue;\n        token.actor.update({ \"data.fatigue.value\": setFatigue });\n        ui.notifications.notify(`${genericHealFatigue} Level(s) of Fatigue cured.`);\n        if (looseFatigueSFX && genericHealFatigue > 0) {\n            AudioHelper.play({ src: `${looseFatigueSFX}` }, true);\n        }\n    }\n\n    function applyWounds() {\n        setWounds = wv + 1\n        if (setWounds <= wm) {\n            token.actor.update({ \"data.wounds.value\": setWounds });\n            if (woundedSFX) {\n                AudioHelper.play({ src: `${woundedSFX}` }, true);\n            }\n        }\n        else {\n            token.actor.update({ \"data.wounds.value\": wm });\n            game.cub.addCondition(\"Incapacitated\");\n            if (incapSFX) {\n                AudioHelper.play({ src: `${incapSFX}` }, true);\n            }\n        }\n    }\n\n    async function wait(ms) {\n        return new Promise(resolve => {\n            setTimeout(resolve, ms);\n        });\n    }\n    // v.3.1.1 By SalieriC#8263; fixing bugs supported by FloRad#2142. Potion usage inspired by grendel111111#1603; asynchronous playback of sfx by Freeze#2689.\n}","author":"wpWSO3unowg8siJN","img":"icons/commodities/materials/bowl-powder-blue.webp","actorIds":[]}
{"_id":"mtxtj7LJqhu94m8H","name":"Unstun","permission":{"default":0,"wpWSO3unowg8siJN":3},"type":"script","flags":{"combat-utility-belt":{"macroTrigger":""},"core":{"sourceId":"Macro.5XICveYBi2K3XduI"}},"scope":"global","command":"//!DOESN'T REROLL ON BENNY; USES UNSHAKE CODE INSTEAD!\nmain();\n\nasync function main() {\n  // No Token is Selected\n  if (!token || canvas.tokens.controlled.length > 1) {\n    ui.notifications.error(\"Please select a single token first.\");\n    return;\n  }\n\n  // Setting up the prone condition image path\n  let proneIconPath = game.settings.get(\n    'swim', 'proneIMG');\n  // Setting up SFX path.\n  let stunSFX = game.settings.get(\n    'swim', 'stunSFX');\n\n  // Checking for SWADE Spices & Flavours and setting up the Benny image.\n  let bennyImage = \"icons/commodities/currency/coin-embossed-octopus-gold.webp\";\n  if (game.modules.get(\"swade-spices\")?.active) {\n    let benny_Back = game.settings.get(\n      'swade-spices', 'bennyBack');\n    if (benny_Back) {\n      bennyImage = benny_Back;\n    }\n  }\n\n  //Checking for Elan\n  const elan = token.actor.data.items.find(function (item) {\n    return item.name.toLowerCase() === \"elan\" && item.type === \"edge\";\n  });\n  let bennies;\n  let bv;\n  let elanBonus;\n\n  async function rollUnstun() {\n\n    const edgeNames = ['combat reflexes'];\n    const actorAlias = speaker.alias;\n    // ROLL VIGOR AND CHECK COMBAT REFLEXES\n    const r = await token.actor.rollAttribute('vigor');\n    const edges = token.actor.data.items.filter(function (item) {\n      return edgeNames.includes(item.name.toLowerCase()) && (item.type === \"edge\" || item.type === \"ability\");\n    });\n    let rollWithEdge = r.total;\n    let edgeText = \"\";\n    for (let edge of edges) {\n      rollWithEdge += 2;\n      edgeText += `<br/><i>+ ${edge.name}</i>`;\n    }\n\n    // Apply +2 if Elan is present and if it is a reroll.\n    if (typeof elanBonus === \"number\") {\n      rollWithEdge += 2;\n      edgeText = edgeText + `<br/><i>+ Elan</i>.`;\n    }\n\n    let chatData = `${actorAlias} rolled <span style=\"font-size:150%\"> ${rollWithEdge} </span>`;\n    // Checking for a Critical Failure.\n    if (isSame_bool(r.dice) && isSame_numb(r.dice) === 1) {\n      ui.notifications.notify(\"You've rolled a Critical Failure!\");\n      let chatData = `${actorAlias} rolled a <span style=\"font-size:150%\"> Critical Failure! </span>`;\n      ChatMessage.create({ content: chatData });\n    }\n    else {\n      if (rollWithEdge > 3 && rollWithEdge <= 7) {\n        chatData += ` and is no longer Stunned but remains Vulnerable until end of next turn.`;\n        token.actor.update({ \"data.status.isVulnerable\": true });\n        token.actor.update({ \"data.status.isStunned\": false });\n        useBenny();\n      } else if (rollWithEdge >= 8) {\n        chatData += `, is no longer Stunned and looses Vulnerable after the turn.`;\n        token.actor.update({ \"data.status.isDistracted\": false });\n        token.actor.update({ \"data.status.isStunned\": false });\n        token.actor.update({ \"data.status.isVulnerable\": false });\n        if (token.data.effects.includes(`${proneIconPath}`)) {\n          token.toggleEffect(`${proneIconPath}`)\n        }\n      } else {\n        chatData += ` and remains Stunned.`;\n        useBenny();\n      }\n      chatData += ` ${edgeText}`;\n    }\n    ChatMessage.create({ content: chatData });\n  }\n\n  // Functions to determine a critical failure. This one checks if all dice rolls are the same.\n  function isSame_bool(d = []) {\n    return d.reduce((c, a, i) => {\n      if (i === 0) return true;\n      return c && a.total === d[i - 1].total;\n    }, true);\n  }\n\n  // Functions to determine a critical failure. This one checks what the number of the \"same\" was.\n  function isSame_numb(d = []) {\n    return d.reduce((c, a, i) => {\n      if (i === 0 || d[i - 1].total === a.total) return a.total;\n      return null;\n    }, 0);\n  }\n\n  function useBenny() {\n    bv = checkBennies();\n    if (bv > 0) {\n      new Dialog({\n        title: 'Spend a Benny?',\n        content: `Do you want to spend a Benny to reroll? (You have ${bv} Bennies left.)`,\n        buttons: {\n          one: {\n            label: \"Yes.\",\n            callback: (html) => {\n              spendBenny();\n              if (!!elan) {\n                elanBonus = 2;\n              }\n              rollUnstun();\n            }\n          },\n          two: {\n            label: \"No.\",\n            callback: (html) => { return; },\n          }\n        },\n        default: \"one\"\n      }).render(true)\n    }\n    else {\n      return;\n    }\n  }\n\n  // Check for Bennies\n  function checkBennies() {\n    bennies = token.actor.data.data.bennies.value;\n\n    // Non GM token has <1 bennie OR GM user AND selected token has <1 benny\n    if ((!game.user.isGM && bennies < 1) || (game.user.isGM && bennies < 1 && game.user.getFlag(\"swade\", \"bennies\") < 1)) {\n      ui.notifications.error(\"You have no more bennies left.\");\n    }\n    if (game.user.isGM) {\n      bv = bennies + game.user.getFlag(\"swade\", \"bennies\");\n    }\n    else {\n      bv = bennies;\n    }\n    return bv;\n  }\n\n  // Spend Benny function\n  async function spendBenny() {\n    bennies = token.actor.data.data.bennies.value;\n    //Subtract the spend, use GM benny if user is GM and token has no more bennies left or spend token benny if user is player and/or token has bennies left.\n    if (game.user.isGM && bennies < 1) {\n      game.user.setFlag(\"swade\", \"bennies\", game.user.getFlag(\"swade\", \"bennies\") - 1)\n    } else {\n      token.actor.update({\n        \"data.bennies.value\": bennies - 1,\n      })\n    }\n\n    //Show the Benny Flip\n    if (game.dice3d) {\n      game.dice3d.showForRoll(new Roll(\"1dB\").roll(), game.user, true, null, false);\n    }\n\n    //Chat Message to let the everyone know a benny was spent\n    ChatMessage.create({\n      user: game.user._id,\n      content: `<p><img style=\"border: none;\" src=\"${bennyImage}\"\" width=\"25\" height=\"25\" /> ${game.user.name} spent a Benny for ${token.name}.</p>`,\n    });\n  }\n\n  if (token.actor.data.data.status.isStunned === true) {\n    rollUnstun()\n  } else if (token) {\n    if (token.actor.data.data.status.isStunned === false) {\n      token.actor.update({ \"data.status.isStunned\": true });\n    };\n\n    if (!token.data.effects.includes(`${proneIconPath}`)) {\n      token.toggleEffect(`${proneIconPath}`)\n    };\n    token.actor.update({ \"data.status.isDistracted\": true });\n    token.actor.update({ \"data.status.isVulnerable\": true });\n    if (stunSFX) {\n      AudioHelper.play({ src: `${stunSFX}` }, true);\n    }\n  }\n  // v.3.3.0 Made by SalieriC#8263 using original Code from Shteff.\n}","author":"wpWSO3unowg8siJN","img":"modules/swim/assets/icons/status_markers/2-Stunned.png","actorIds":[]}
{"_id":"49TiCaAgArpHsAhz","name":"SWIM: Ammo usage","permission":{"default":0,"wpWSO3unowg8siJN":3},"type":"script","flags":{"combat-utility-belt":{"macroTrigger":""},"furnace":{"runAsGM":false},"core":{"sourceId":"Macro.mMb87BLxl6JfQXQ1"}},"scope":"global","command":"checkWeapon();\n\nasync function checkWeapon() {\n    //Don't execute the macro on a reroll by checking if the old_rolls is empty:\n    if (message.data.flags['betterrolls-swade2'].render_data.trait_roll.old_rolls.length >= 1) { return; }\n    //Check whether or not the weapon is suitable for the shooting macro\n    if (\n        (item.type === \"weapon\" &&\n            //i.data.data.range !== \"0\" && i.data.data.range !== \"\" &&\n            item.data.data.ammo.trim() !== \"\" &&\n            item.data.data.quantity > 0) ||\n        (item.type === \"weapon\" &&\n            //i.data.data.range !== \"0\" && i.data.data.range !== \"\" &&\n            item.data.data.additionalStats.isConsumable &&\n            item.data.data.additionalStats.isConsumable.value === true &&\n            item.data.data.quantity > 0)\n    ) { shoot(); }\n    else { return; }\n}\n\nasync function shoot() {\n    //let [shots, weapon, ammo, sil] = getValues(html);\n    let item_weapon = item;\n    //Stop if the item is not a weapon:\n    if (item_weapon.type != \"weapon\") { return; }\n    //Get ammo loaded in the weapon and amount of shots provided by BR2 as well as a silenced state:\n    let item_ammo;\n    if (item_weapon.data.data.additionalStats.loadedAmmo) {\n        let loaded_ammo = item_weapon.data.data.additionalStats.loadedAmmo.value;\n        item_ammo = actor.items.getName(`${loaded_ammo}`);\n    }\n    //Setting the amount of shots based on RoF:\n    let traitDice = message.data.flags['betterrolls-swade2'].render_data.trait_roll.dice;\n    //console.log(traitDice);\n    console.log(message.data.flags['betterrolls-swade2'].render_data);\n    let rate_of_fire = traitDice.length;\n    if (actor.data.data.wildcard === true) { rate_of_fire = rate_of_fire - 1; }\n    //console.log(rate_of_fire);\n    let shots;\n    if (rate_of_fire === 1) { shots = 1; }\n    if (rate_of_fire === 2) { shots = 5; }\n    if (rate_of_fire === 3) { shots = 10; }\n    if (rate_of_fire === 4) { shots = 20; }\n    if (rate_of_fire === 5) { shots = 40; }\n    if (rate_of_fire === 6) { shots = 50; }\n\n    let sil = false;\n    if (item_weapon.data.data.additionalStats.silenced && item_weapon.data.data.additionalStats.silenced.value === true) {\n        sil = true;\n    }\n    // Getting the sfx from the weapon provided by BR2:\n    let sfx_shot;\n    let sfx_silenced;\n    let sfx_shot_auto;\n    let sfx_silenced_auto;\n    let sfx_empty;\n    if (item_weapon.data.data.additionalStats.sfx) {\n        let sfx = item_weapon.data.data.additionalStats.sfx.value.split(`|`);\n        sfx_shot = sfx[1];\n        sfx_silenced = sfx[3];\n        sfx_shot_auto = sfx[2];\n        sfx_silenced_auto = sfx[4];\n        sfx_empty = sfx[5];\n    }\n    // Getting Weapon and loaded ammo\n    const weaponIMG = item_weapon.data.img;\n    let currentAmmo\n    if (item_weapon.data.data.additionalStats.loadedAmmo) {\n        currentAmmo = item_weapon.data.data.additionalStats.loadedAmmo.value;\n    }\n\n    // Calculating shots to expend\n    const currentCharges = parseInt(item_weapon.data.data.currentShots);\n    const newCharges = currentCharges - shots;\n    if (item_weapon.data.data.additionalStats.isConsumable && item_weapon.data.data.additionalStats.isConsumable.value === true) {\n        const currentQuantity = parseInt(item_weapon.data.data.quantity);\n        if (currentQuantity <= 0) {\n            return ui.notifications.error(`You don't have a ${item_weapon.name} left.`);\n        }\n        const newQuantity = currentQuantity - shots;\n        const updates = [\n            { _id: item_weapon.id, \"data.quantity\": `${newQuantity}` },\n        ];\n        // Updating the consumable weapon\n        await actor.updateOwnedItem(updates);\n        // Deleting the consumable weapon if it was the last\n        if (newQuantity <= 0) {\n            item_weapon.delete();\n        }\n        // Creating the Chat message\n        ChatMessage.create({\n            speaker: {\n                alias: actor.name\n            },\n            content: `<img src=\"${weaponIMG}\" alt=\"\" width=\"25\" height=\"25\" /> ${actor.name} uses ${shots} ${item_weapon.name}(s) and has ${newQuantity} left.`\n        })\n        // Play sound effects\n        if (sfx_shot) {\n            AudioHelper.play({ src: `${sfx_shot}` }, true);\n        }\n    }\n    // Check if enough bullets are in the weapon to fire the given amount of shots if this is not a consumable weapon.\n    else if (currentCharges < shots) {\n        ui.notifications.error(\"You have insufficient ammunition.\");\n        if (sfx_empty && currentCharges === 0) {\n            AudioHelper.play({ src: `${sfx_empty}` }, true);\n        }\n        return;\n    }\n    else {\n        const updates = [\n            { _id: item_weapon.id, \"data.currentShots\": `${newCharges}` },\n        ];\n        // Updating the Weapon\n        actor.updateOwnedItem(updates);\n        // Creating the Chat message\n        if (!currentAmmo) {\n            ChatMessage.create({\n                speaker: {\n                    alias: actor.name\n                },\n                content: `<img src=\"${weaponIMG}\" alt=\"\" width=\"25\" height=\"25\" /> ${actor.name} fires <b>${shots} round(s)</b> from a ${item_weapon.name} and has <b>${newCharges} left</b>.`\n            })\n        } else {\n            ChatMessage.create({\n                speaker: {\n                    alias: actor.name\n                },\n                content: `<img src=\"${weaponIMG}\" alt=\"\" width=\"25\" height=\"25\" /> ${actor.name} fires <b>${shots} ${currentAmmo} round(s)</b> from a ${item_weapon.name} and has <b>${newCharges} left</b>.`\n            })\n        }\n        // Play sound effects\n        if (sil === true && sfx_silenced) {\n            if (shots > 4 && sfx_silenced_auto) {\n                AudioHelper.play({ src: `${sfx_silenced_auto}` }, true);\n            }\n            else {\n                AudioHelper.play({ src: `${sfx_silenced}` }, true);\n            }\n        }\n        else {\n            if (shots > 4 && sfx_shot_auto) {\n                AudioHelper.play({ src: `${sfx_shot_auto}` }, true);\n            }\n            else {\n                AudioHelper.play({ src: `${sfx_shot}` }, true);\n            }\n        }\n    }\n    //V. 1.0.0 by SalieriC#8263 with help from javierrivera#4813.\n}","author":"wpWSO3unowg8siJN","img":"icons/weapons/crossbows/crossbow-long-brown.webp","actorIds":[]}
{"_id":"49TiCaAgArpHsAhz","name":"SWIM: Ammo usage","permission":{"default":0,"wpWSO3unowg8siJN":3},"type":"script","flags":{"combat-utility-belt":{"macroTrigger":""},"furnace":{"runAsGM":false},"core":{"sourceId":"Macro.mMb87BLxl6JfQXQ1"}},"scope":"global","command":"checkWeapon();\n\nasync function checkWeapon() {\n    //Don't execute the macro on a reroll by checking if the old_rolls is empty:\n    if (message.data.flags['betterrolls-swade2'].render_data.trait_roll.old_rolls.length >= 1) { return; }\n    //Check whether or not the weapon is suitable for the shooting macro\n    if (\n        (item.type === \"weapon\" &&\n            //i.data.data.range !== \"0\" && i.data.data.range !== \"\" &&\n            item.data.data.ammo.trim() !== \"\" &&\n            item.data.data.quantity > 0) ||\n        (item.type === \"weapon\" &&\n            //i.data.data.range !== \"0\" && i.data.data.range !== \"\" &&\n            item.data.data.additionalStats.isConsumable &&\n            item.data.data.additionalStats.isConsumable.value === true &&\n            item.data.data.quantity > 0)\n    ) { shoot(); }\n    else { return; }\n}\n\nasync function shoot() {\n    //let [shots, weapon, ammo, sil] = getValues(html);\n    let item_weapon = item;\n    //Stop if the item is not a weapon:\n    if (item_weapon.type != \"weapon\") { return; }\n    //Get ammo loaded in the weapon and amount of shots provided by BR2 as well as a silenced state:\n    let item_ammo;\n    if (item_weapon.data.data.additionalStats.loadedAmmo) {\n        let loaded_ammo = item_weapon.data.data.additionalStats.loadedAmmo.value;\n        item_ammo = actor.items.getName(`${loaded_ammo}`);\n    }\n    //Setting the amount of shots based on RoF:\n    let traitDice = message.data.flags['betterrolls-swade2'].render_data.trait_roll.dice;\n    //console.log(traitDice);\n    //console.log(message.data.flags['betterrolls-swade2'].render_data);\n    let rate_of_fire = traitDice.length;\n    if (actor.data.data.wildcard === true) { rate_of_fire = rate_of_fire - 1; }\n    //console.log(rate_of_fire);\n    let shots;\n    if (rate_of_fire === 1) { shots = 1; }\n    if (rate_of_fire === 2) { shots = 5; }\n    if (rate_of_fire === 3) { shots = 10; }\n    if (rate_of_fire === 4) { shots = 20; }\n    if (rate_of_fire === 5) { shots = 40; }\n    if (rate_of_fire === 6) { shots = 50; }\n\n    let sil = false;\n    if (item_weapon.data.data.additionalStats.silenced && item_weapon.data.data.additionalStats.silenced.value === true) {\n        sil = true;\n    }\n    // Getting the sfx from the weapon provided by BR2:\n    let sfx_shot;\n    let sfx_silenced;\n    let sfx_shot_auto;\n    let sfx_silenced_auto;\n    let sfx_empty;\n    if (item_weapon.data.data.additionalStats.sfx) {\n        let sfx = item_weapon.data.data.additionalStats.sfx.value.split(`|`);\n        sfx_shot = sfx[1];\n        sfx_silenced = sfx[3];\n        sfx_shot_auto = sfx[2];\n        sfx_silenced_auto = sfx[4];\n        sfx_empty = sfx[5];\n    }\n    // Getting Weapon and loaded ammo\n    const weaponIMG = item_weapon.data.img;\n    let currentAmmo\n    if (item_weapon.data.data.additionalStats.loadedAmmo) {\n        currentAmmo = item_weapon.data.data.additionalStats.loadedAmmo.value;\n    }\n\n    // Calculating shots to expend\n    const currentCharges = parseInt(item_weapon.data.data.currentShots);\n    const newCharges = currentCharges - shots;\n    if (item_weapon.data.data.additionalStats.isConsumable && item_weapon.data.data.additionalStats.isConsumable.value === true) {\n        const currentQuantity = parseInt(item_weapon.data.data.quantity);\n        if (currentQuantity <= 0) {\n            return ui.notifications.error(`You don't have a ${item_weapon.name} left.`);\n        }\n        const newQuantity = currentQuantity - shots;\n        const updates = [\n            { _id: item_weapon.id, \"data.quantity\": `${newQuantity}` },\n        ];\n        // Updating the consumable weapon\n        await actor.updateOwnedItem(updates);\n        // Deleting the consumable weapon if it was the last\n        if (newQuantity <= 0) {\n            item_weapon.delete();\n        }\n        // Creating the Chat message\n        ChatMessage.create({\n            speaker: {\n                alias: actor.name\n            },\n            content: `<img src=\"${weaponIMG}\" alt=\"\" width=\"25\" height=\"25\" /> ${actor.name} uses ${shots} ${item_weapon.name}(s) and has ${newQuantity} left.`\n        })\n        // Play sound effects\n        if (sfx_shot) {\n            AudioHelper.play({ src: `${sfx_shot}` }, true);\n        }\n    }\n    // Check if enough bullets are in the weapon to fire the given amount of shots if this is not a consumable weapon.\n    else if (currentCharges < shots) {\n        ui.notifications.error(\"You have insufficient ammunition.\");\n        if (sfx_empty && currentCharges === 0) {\n            AudioHelper.play({ src: `${sfx_empty}` }, true);\n        }\n        return;\n    }\n    else {\n        const updates = [\n            { _id: item_weapon.id, \"data.currentShots\": `${newCharges}` },\n        ];\n        // Updating the Weapon\n        actor.updateOwnedItem(updates);\n        // Creating the Chat message\n        if (!currentAmmo) {\n            ChatMessage.create({\n                speaker: {\n                    alias: actor.name\n                },\n                content: `<img src=\"${weaponIMG}\" alt=\"\" width=\"25\" height=\"25\" /> ${actor.name} fires <b>${shots} round(s)</b> from a ${item_weapon.name} and has <b>${newCharges} left</b>.`\n            })\n        } else {\n            ChatMessage.create({\n                speaker: {\n                    alias: actor.name\n                },\n                content: `<img src=\"${weaponIMG}\" alt=\"\" width=\"25\" height=\"25\" /> ${actor.name} fires <b>${shots} ${currentAmmo} round(s)</b> from a ${item_weapon.name} and has <b>${newCharges} left</b>.`\n            })\n        }\n        // Play sound effects\n        if (sil === true && sfx_silenced) {\n            if (shots > 4 && sfx_silenced_auto) {\n                AudioHelper.play({ src: `${sfx_silenced_auto}` }, true);\n            }\n            else {\n                AudioHelper.play({ src: `${sfx_silenced}` }, true);\n            }\n        }\n        else {\n            if (shots > 4 && sfx_shot_auto) {\n                AudioHelper.play({ src: `${sfx_shot_auto}` }, true);\n            }\n            else {\n                AudioHelper.play({ src: `${sfx_shot}` }, true);\n            }\n        }\n    }\n    //V. 1.0.0 by SalieriC#8263 with help from javierrivera#4813.\n}","author":"wpWSO3unowg8siJN","img":"icons/weapons/crossbows/crossbow-long-brown.webp","actorIds":[]}
{"_id":"49TiCaAgArpHsAhz","name":"SWIM: Ammo usage","permission":{"default":0,"wpWSO3unowg8siJN":3},"type":"script","flags":{"combat-utility-belt":{"macroTrigger":""},"furnace":{"runAsGM":false},"core":{"sourceId":"Macro.mMb87BLxl6JfQXQ1"}},"scope":"global","command":"checkWeapon();\n\nasync function checkWeapon() {\n    //Don't execute the macro on a reroll by checking if the old_rolls is empty:\n    if (message.data.flags['betterrolls-swade2'].render_data.trait_roll.old_rolls.length >= 1) { return; }\n    //Check whether or not the weapon is suitable for the shooting macro\n    if (\n        (item.type === \"weapon\" &&\n            //i.data.data.range !== \"0\" && i.data.data.range !== \"\" &&\n            item.data.data.ammo.trim() !== \"\" &&\n            item.data.data.quantity > 0) ||\n        (item.type === \"weapon\" &&\n            //i.data.data.range !== \"0\" && i.data.data.range !== \"\" &&\n            item.data.data.additionalStats.isConsumable &&\n            item.data.data.additionalStats.isConsumable.value === true &&\n            item.data.data.quantity > 0)\n    ) { shoot(); }\n    else { return; }\n}\n\nasync function shoot() {\n    //let [shots, weapon, ammo, sil] = getValues(html);\n    let item_weapon = item;\n    //Stop if the item is not a weapon:\n    if (item_weapon.type != \"weapon\") { return; }\n    //Get ammo loaded in the weapon and amount of shots provided by BR2 as well as a silenced state:\n    let item_ammo;\n    if (item_weapon.data.data.additionalStats.loadedAmmo) {\n        let loaded_ammo = item_weapon.data.data.additionalStats.loadedAmmo.value;\n        item_ammo = actor.items.getName(`${loaded_ammo}`);\n    }\n    //Setting the amount of shots based on RoF:\n    let traitDice = message.data.flags['betterrolls-swade2'].render_data.trait_roll.dice;\n    //console.log(traitDice);\n    //console.log(message.data.flags['betterrolls-swade2'].render_data);\n    let rate_of_fire = traitDice.length;\n    if (actor.data.data.wildcard === true) { rate_of_fire = rate_of_fire - 1; }\n    //console.log(rate_of_fire);\n    let shots;\n    if (rate_of_fire === 1) { shots = 1; }\n    if (rate_of_fire === 2) { shots = 5; }\n    if (rate_of_fire === 3) { shots = 10; }\n    if (rate_of_fire === 4) { shots = 20; }\n    if (rate_of_fire === 5) { shots = 40; }\n    if (rate_of_fire === 6) { shots = 50; }\n\n    let sil = false;\n    if (item_weapon.data.data.additionalStats.silenced && item_weapon.data.data.additionalStats.silenced.value === true) {\n        sil = true;\n    }\n    // Getting the sfx from the weapon provided by BR2:\n    let sfx_shot;\n    let sfx_silenced;\n    let sfx_shot_auto;\n    let sfx_silenced_auto;\n    let sfx_empty;\n    if (item_weapon.data.data.additionalStats.sfx) {\n        let sfx = item_weapon.data.data.additionalStats.sfx.value.split(`|`);\n        sfx_shot = sfx[1];\n        sfx_silenced = sfx[3];\n        sfx_shot_auto = sfx[2];\n        sfx_silenced_auto = sfx[4];\n        sfx_empty = sfx[5];\n    }\n    // Getting Weapon and loaded ammo\n    const weaponIMG = item_weapon.data.img;\n    let currentAmmo\n    if (item_weapon.data.data.additionalStats.loadedAmmo) {\n        currentAmmo = item_weapon.data.data.additionalStats.loadedAmmo.value;\n    }\n\n    // Calculating shots to expend\n    const currentCharges = parseInt(item_weapon.data.data.currentShots);\n    const newCharges = currentCharges - shots;\n    if (item_weapon.data.data.additionalStats.isConsumable && item_weapon.data.data.additionalStats.isConsumable.value === true) {\n        const currentQuantity = parseInt(item_weapon.data.data.quantity);\n        if (currentQuantity <= 0) {\n            return ui.notifications.error(`You don't have a ${item_weapon.name} left.`);\n        }\n        const newQuantity = currentQuantity - shots;\n        const updates = [\n            { _id: item_weapon.id, \"data.quantity\": `${newQuantity}` },\n        ];\n        // Updating the consumable weapon\n        await actor.updateOwnedItem(updates);\n        // Deleting the consumable weapon if it was the last (disabled because it breaks rerolls in BR2)\n        /*if (newQuantity <= 0) {\n            item_weapon.delete();\n        }*/\n        // Creating the Chat message\n        ChatMessage.create({\n            speaker: {\n                alias: actor.name\n            },\n            content: `<img src=\"${weaponIMG}\" alt=\"\" width=\"25\" height=\"25\" /> ${actor.name} uses ${shots} ${item_weapon.name}(s) and has ${newQuantity} left.`\n        })\n        // Play sound effects\n        if (sfx_shot) {\n            AudioHelper.play({ src: `${sfx_shot}` }, true);\n        }\n    }\n    // Check if enough bullets are in the weapon to fire the given amount of shots if this is not a consumable weapon.\n    else if (currentCharges < shots) {\n        ui.notifications.error(\"You have insufficient ammunition.\");\n        if (sfx_empty && currentCharges === 0) {\n            AudioHelper.play({ src: `${sfx_empty}` }, true);\n        }\n        return;\n    }\n    else {\n        const updates = [\n            { _id: item_weapon.id, \"data.currentShots\": `${newCharges}` },\n        ];\n        // Updating the Weapon\n        actor.updateOwnedItem(updates);\n        // Creating the Chat message\n        if (!currentAmmo) {\n            ChatMessage.create({\n                speaker: {\n                    alias: actor.name\n                },\n                content: `<img src=\"${weaponIMG}\" alt=\"\" width=\"25\" height=\"25\" /> ${actor.name} fires <b>${shots} round(s)</b> from a ${item_weapon.name} and has <b>${newCharges} left</b>.`\n            })\n        } else {\n            ChatMessage.create({\n                speaker: {\n                    alias: actor.name\n                },\n                content: `<img src=\"${weaponIMG}\" alt=\"\" width=\"25\" height=\"25\" /> ${actor.name} fires <b>${shots} ${currentAmmo} round(s)</b> from a ${item_weapon.name} and has <b>${newCharges} left</b>.`\n            })\n        }\n        // Play sound effects\n        if (sil === true && sfx_silenced) {\n            if (shots > 4 && sfx_silenced_auto) {\n                AudioHelper.play({ src: `${sfx_silenced_auto}` }, true);\n            }\n            else {\n                AudioHelper.play({ src: `${sfx_silenced}` }, true);\n            }\n        }\n        else {\n            if (shots > 4 && sfx_shot_auto) {\n                AudioHelper.play({ src: `${sfx_shot_auto}` }, true);\n            }\n            else {\n                AudioHelper.play({ src: `${sfx_shot}` }, true);\n            }\n        }\n    }\n    //V. 1.0.0 by SalieriC#8263 with help from javierrivera#4813.\n}","author":"wpWSO3unowg8siJN","img":"icons/weapons/crossbows/crossbow-long-brown.webp","actorIds":[]}
{"_id":"49TiCaAgArpHsAhz","name":"SWIM: Ammo usage","permission":{"default":0,"wpWSO3unowg8siJN":3},"type":"script","flags":{"combat-utility-belt":{"macroTrigger":""},"furnace":{"runAsGM":false},"core":{"sourceId":"Macro.mMb87BLxl6JfQXQ1"}},"scope":"global","command":"checkWeapon();\n\nasync function checkWeapon() {\n    //Don't execute the macro on a reroll by checking if the old_rolls is empty:\n    if (message.data.flags['betterrolls-swade2'].render_data.trait_roll.old_rolls.length >= 1) { return; }\n    //Check whether or not the weapon is suitable for the shooting macro\n    if (\n        (item.type === \"weapon\" &&\n            //i.data.data.range !== \"0\" && i.data.data.range !== \"\" &&\n            item.data.data.ammo.trim() !== \"\" &&\n            item.data.data.quantity > 0) ||\n        (item.type === \"weapon\" &&\n            //i.data.data.range !== \"0\" && i.data.data.range !== \"\" &&\n            item.data.data.additionalStats.isConsumable &&\n            item.data.data.additionalStats.isConsumable.value === true /*&&\n            //Ignore quantity to get a notification below for BR2 integration.\n            item.data.data.quantity > 0*/)\n    ) { shoot(); }\n    else { return; }\n}\n\nasync function shoot() {\n    //let [shots, weapon, ammo, sil] = getValues(html);\n    let item_weapon = item;\n    //Stop if the item is not a weapon:\n    if (item_weapon.type != \"weapon\") { return; }\n    //Get ammo loaded in the weapon and amount of shots provided by BR2 as well as a silenced state:\n    let item_ammo;\n    if (item_weapon.data.data.additionalStats.loadedAmmo) {\n        let loaded_ammo = item_weapon.data.data.additionalStats.loadedAmmo.value;\n        item_ammo = actor.items.getName(`${loaded_ammo}`);\n    }\n    //Setting the amount of shots based on RoF:\n    let traitDice = message.data.flags['betterrolls-swade2'].render_data.trait_roll.dice;\n    //console.log(traitDice);\n    //console.log(message.data.flags['betterrolls-swade2'].render_data);\n    let rate_of_fire = traitDice.length;\n    if (actor.data.data.wildcard === true) { rate_of_fire = rate_of_fire - 1; }\n    //console.log(rate_of_fire);\n    let shots;\n    if (rate_of_fire === 1) { shots = 1; }\n    if (rate_of_fire === 2) { shots = 5; }\n    if (rate_of_fire === 3) { shots = 10; }\n    if (rate_of_fire === 4) { shots = 20; }\n    if (rate_of_fire === 5) { shots = 40; }\n    if (rate_of_fire === 6) { shots = 50; }\n\n    let sil = false;\n    if (item_weapon.data.data.additionalStats.silenced && item_weapon.data.data.additionalStats.silenced.value === true) {\n        sil = true;\n    }\n    // Getting the sfx from the weapon provided by BR2:\n    let sfx_shot;\n    let sfx_silenced;\n    let sfx_shot_auto;\n    let sfx_silenced_auto;\n    let sfx_empty;\n    if (item_weapon.data.data.additionalStats.sfx) {\n        let sfx = item_weapon.data.data.additionalStats.sfx.value.split(`|`);\n        sfx_shot = sfx[1];\n        sfx_silenced = sfx[3];\n        sfx_shot_auto = sfx[2];\n        sfx_silenced_auto = sfx[4];\n        sfx_empty = sfx[5];\n    }\n    // Getting Weapon and loaded ammo\n    const weaponIMG = item_weapon.data.img;\n    let currentAmmo\n    if (item_weapon.data.data.additionalStats.loadedAmmo) {\n        currentAmmo = item_weapon.data.data.additionalStats.loadedAmmo.value;\n    }\n\n    // Calculating shots to expend\n    const currentCharges = parseInt(item_weapon.data.data.currentShots);\n    const newCharges = currentCharges - shots;\n    if (item_weapon.data.data.additionalStats.isConsumable && item_weapon.data.data.additionalStats.isConsumable.value === true) {\n        const currentQuantity = parseInt(item_weapon.data.data.quantity);\n        if (currentQuantity <= 0) {\n            return ui.notifications.error(`You don't have a ${item_weapon.name} left.`);\n        }\n        const newQuantity = currentQuantity - shots;\n        const updates = [\n            { _id: item_weapon.id, \"data.quantity\": `${newQuantity}` },\n        ];\n        // Updating the consumable weapon\n        await actor.updateOwnedItem(updates);\n        // Deleting the consumable weapon if it was the last (disabled because it breaks rerolls in BR2)\n        /*if (newQuantity <= 0) {\n            item_weapon.delete();\n        }*/\n        // Creating the Chat message\n        ChatMessage.create({\n            speaker: {\n                alias: actor.name\n            },\n            content: `<img src=\"${weaponIMG}\" alt=\"\" width=\"25\" height=\"25\" /> ${actor.name} uses ${shots} ${item_weapon.name}(s) and has ${newQuantity} left.`\n        })\n        // Play sound effects\n        if (sfx_shot) {\n            AudioHelper.play({ src: `${sfx_shot}` }, true);\n        }\n    }\n    // Check if enough bullets are in the weapon to fire the given amount of shots if this is not a consumable weapon.\n    else if (currentCharges < shots) {\n        ui.notifications.error(\"You have insufficient ammunition.\");\n        if (sfx_empty && currentCharges === 0) {\n            AudioHelper.play({ src: `${sfx_empty}` }, true);\n        }\n        return;\n    }\n    else {\n        const updates = [\n            { _id: item_weapon.id, \"data.currentShots\": `${newCharges}` },\n        ];\n        // Updating the Weapon\n        actor.updateOwnedItem(updates);\n        // Creating the Chat message\n        if (!currentAmmo) {\n            ChatMessage.create({\n                speaker: {\n                    alias: actor.name\n                },\n                content: `<img src=\"${weaponIMG}\" alt=\"\" width=\"25\" height=\"25\" /> ${actor.name} fires <b>${shots} round(s)</b> from a ${item_weapon.name} and has <b>${newCharges} left</b>.`\n            })\n        } else {\n            ChatMessage.create({\n                speaker: {\n                    alias: actor.name\n                },\n                content: `<img src=\"${weaponIMG}\" alt=\"\" width=\"25\" height=\"25\" /> ${actor.name} fires <b>${shots} ${currentAmmo} round(s)</b> from a ${item_weapon.name} and has <b>${newCharges} left</b>.`\n            })\n        }\n        // Play sound effects\n        if (sil === true && sfx_silenced) {\n            if (shots > 4 && sfx_silenced_auto) {\n                AudioHelper.play({ src: `${sfx_silenced_auto}` }, true);\n            }\n            else {\n                AudioHelper.play({ src: `${sfx_silenced}` }, true);\n            }\n        }\n        else {\n            if (shots > 4 && sfx_shot_auto) {\n                AudioHelper.play({ src: `${sfx_shot_auto}` }, true);\n            }\n            else {\n                AudioHelper.play({ src: `${sfx_shot}` }, true);\n            }\n        }\n    }\n    //V. 1.0.0 by SalieriC#8263 with help from javierrivera#4813.\n}","author":"wpWSO3unowg8siJN","img":"icons/weapons/crossbows/crossbow-long-brown.webp","actorIds":[]}
{"_id":"gB5U6GYNh86mA8F2","name":"Ammo Management (enhanced) [READ THE DOC!]","permission":{"default":0,"wpWSO3unowg8siJN":3},"type":"script","flags":{"combat-utility-belt":{"macroTrigger":""},"core":{"sourceId":"Macro.XEYSVDTmQli1bqlu"}},"scope":"global","command":"// Preset for SFX of weapons (Without the //):\n//RELOAD|FIRE|AUTOFIRE|SILENCED|SILENCEDAUTOFIRE|EMPTY\n\nlet dialogID = \"\";\n\nasync function wait(ms) {\n    return new Promise(resolve => {\n        setTimeout(resolve, ms);\n    });\n}\n\nasync function weaponDialog() {\n  if (!token) return ui.notifications.error(\"Please select a token first\");\n\n  const actor = token.actor;\n  const weapons = actor.items.filter(i =>\n    (i.type === \"weapon\" &&\n      //i.data.data.range !== \"0\" && i.data.data.range !== \"\" &&\n      i.data.data.ammo.trim() !== \"\" &&\n      i.data.data.quantity > 0) ||\n    (i.type === \"weapon\" &&\n      //i.data.data.range !== \"0\" && i.data.data.range !== \"\" &&\n      i.data.data.additionalStats.isConsumable &&\n      i.data.data.additionalStats.isConsumable.value === true &&\n      i.data.data.quantity > 0)\n  );\n\n  if (weapons.length === 0) return ui.notifications.error(\"You have no reloadable or consumable weapons.\");\n\n  let html = getHTML();\n  let content = getContent();\n  let buttons = getButtons();\n\n  let dialog = new Dialog({\n    content, buttons, title: `Attack Dialog`\n  }, {\n    width: 400,\n  });\n\n  dialogID = dialog.appId;\n\n  await dialog._render(true);\n  activeListeners();\n\n  function getHTML() {\n    let html = document.getElementById(`app-${dialogID}`)?.getElementsByTagName(`select`);\n    if (html === undefined) return undefined;\n    else return Array.from(html).map(h => h.value);\n  }\n  function getContent() {\n    let selectedWeapon = html !== undefined\n      ? html[0]\n      : weapons[0].id;\n\n    //console.log(html, selectedWeapon, weapons);\n\n    //Get ammo and filter for the ammo the token actually owns.\n    let ammo = weapons\n      .find(w => w.id === selectedWeapon).data.data.ammo.trim().split(`|`)\n      .filter(a => !!actor.items.getName(a));\n\n    let rate_of_fire = parseInt(weapons.find(w => w.id === selectedWeapon).data.data.rof);\n    let defaultShots = 1;\n    if (rate_of_fire === 2) { defaultShots = 5; }\n    if (rate_of_fire === 3) { defaultShots = 10; }\n    if (rate_of_fire === 4) { defaultShots = 20; }\n    if (rate_of_fire === 5) { defaultShots = 40; }\n    if (rate_of_fire === 6) { defaultShots = 50; }\n\n    return `\n    <form>\n      <div>\n        <p>Here you can fire shots from your weapon or reload it.</p>\n        <p>You don't need to adjust the \"# of Shots\" for realoading. If you change the ammo type you'll keep the old ammo unless it is a Charge Pack.</p>\n        <p><b># of Shots per ROF:</b> ROF 1 = 1 Shot; ROF 2 = 5; ROF 3 = 10; ROF 4 = 20; ROF 5 = 40; ROF 6 = 50</p>\n      </div>\n      <div class=\"form-group\">\n        <label for=\"shots\"># of Shots: </label>\n        <input id=\"shots\" type=\"number\" min=\"0\" value=\"${defaultShots}\"></input>\n      </div>\n      <div class=\"form-group\">\n        <label for=\"weapon\">Weapon: </label>\n        <select id=\"weapon\">${weapons.reduce((acc, val) => acc += `<option value=\"${val.id}\" ${val.id === selectedWeapon ? `selected` : ``}>${val.name}</option>`, ``)}</select>\n      </div>\n      <div class=\"form-group\">\n        <label for=\"ammo\">Ammo: </label>\n        <select id=\"ammo\">${ammo.reduce((acc, val) => acc += `<option value=\"${val}\">${val}</option>`, ``)}</select>\n      </div>\n      <div class=\"form-group\">\n        <label for=\"singleReload\">Can only reload one at a time: </label>\n        <input id=\"singleReload\" name=\"Single Reload\" type=\"checkbox\"></input>\n      </div>\n    </form>\n    `\n  }\n  function getButtons() {\n    return {\n      a: {\n        label: \"Shoot\", callback: shoot,\n      },\n      b: {\n        label: \"Reload\", callback: reload,\n      }\n    }\n  }\n  function activeListeners() {\n    document.getElementById(\"weapon\").onchange = update;\n  }\n  async function update() {\n    html = getHTML();\n    dialog.data.content = getContent();\n    dialog.data.buttons = getButtons();\n    await dialog._render(true);\n    activeListeners();\n  }\n  async function shoot(html) {\n    let [shots, weapon, ammo] = getValues(html);\n    let item_weapon = actor.items.get(weapon);\n    let item_ammo = actor.items.getName(`${ammo}`);\n    // Getting sfxDelay from game settings\n    let sfxDelay = game.settings.get(\n        'swim', 'sfxDelay');\n    // Getting the sfx from the selected weapon\n    let sfx_shot/* = stuff*/;\n    let sfx_silenced/* = stuff*/;\n    let sfx_shot_auto/* = stuff*/;\n    let sfx_silenced_auto/* = stuff*/;\n    let sfx_empty;\n    if (item_weapon.data.data.additionalStats.sfx) {\n      let sfx = item_weapon.data.data.additionalStats.sfx.value.split(`|`);\n      sfx_shot = sfx[1];\n      sfx_silenced = sfx[3];\n      sfx_shot_auto = sfx[2];\n      sfx_silenced_auto = sfx[4];\n      sfx_empty = sfx[5];\n    }\n    // Setting a boolean depending on whether or not a weapon is silenced\n    let sil = false;\n    if (item_weapon.data.data.additionalStats.silenced && item_weapon.data.data.additionalStats.silenced.value === true) {\n      sil = true;\n    }\n    // Getting Weapon and loaded ammo\n    const weaponIMG = item_weapon.data.img;\n    let currentAmmo\n    if (item_weapon.data.data.additionalStats.loadedAmmo) {\n      currentAmmo = item_weapon.data.data.additionalStats.loadedAmmo.value;\n    }\n\n    // Calculating shots to expend\n    const currentCharges = parseInt(item_weapon.data.data.currentShots);\n    const newCharges = currentCharges - shots;\n    if (item_weapon.data.data.additionalStats.isConsumable && item_weapon.data.data.additionalStats.isConsumable.value === true) {\n      const currentQuantity = parseInt(item_weapon.data.data.quantity);\n      if (currentQuantity <= 0) {\n        return ui.notifications.error(`You don't have a ${item_weapon.name} left.`);\n      }\n      const newQuantity = currentQuantity - shots;\n      const updates = [\n        { _id: item_weapon.id, \"data.quantity\": `${newQuantity}` },\n      ];\n      // Updating the consumable weapon\n      await actor.updateOwnedItem(updates);\n      // Deleting the consumable weapon if it was the last\n      if (newQuantity <= 0) {\n        item_weapon.delete();\n      }\n      // Creating the Chat message\n      ChatMessage.create({\n        speaker: {\n          alias: token.name\n        },\n        content: `<img src=\"${weaponIMG}\" alt=\"\" width=\"25\" height=\"25\" /> ${token.name} uses ${shots} ${item_weapon.name}(s) and has ${newQuantity} left.`\n      })\n      // Play sound effects\n      if (sfx_shot) {\n        AudioHelper.play({ src: `${sfx_shot}` }, true);\n      }\n    }\n    //Stuff for weapons with \"doesn't require reload action\" checked:\n    else if (item_weapon.data.data.autoReload === true) {\n      //Throw error if no ammo is left.\n      console.log(item_ammo);\n      if (item_ammo.data.data.quantity <= 0) { return ui.notifications.error(`You don't have a ${item_ammo.name} left.`); }\n      else {\n        //Setting new constants to overwrite the old ones\n        const currentCharges = parseInt(item_ammo.data.data.quantity);\n        const newCharges = currentCharges - shots;\n        //Setting up the updates\n        const updates = [\n          { _id: item_ammo.id, \"data.quantity\": `${newCharges}` },\n        ];\n        // Updating the Weapon\n        actor.updateOwnedItem(updates);\n        //Creating the chat message\n        ChatMessage.create({\n          speaker: {\n            alias: actor.name\n          },\n          content: `<img src=\"${weaponIMG}\" alt=\"\" width=\"25\" height=\"25\" /> ${actor.name} fires <b>${shots} ${currentAmmo} round(s)</b> from a ${item_weapon.name} and has <b>${newCharges} left</b>.`\n        })\n        //Playing the SFX\n        // Play sound effects\n        if (sil === true && sfx_silenced) {\n          if (shots === 2) {\n            AudioHelper.play({ src: `${sfx_silenced}` }, true);\n            await wait(`${sfxDelay}`);\n            AudioHelper.play({ src: `${sfx_silenced}` }, true);\n          }\n          else if (shots === 3) {\n            //console.log(\"I AM HERE!\");\n            AudioHelper.play({ src: `${sfx_silenced}` }, true);\n            await wait(`${sfxDelay}`);\n            AudioHelper.play({ src: `${sfx_silenced}` }, true);\n            await wait(`${sfxDelay}`);\n            AudioHelper.play({ src: `${sfx_silenced}` }, true);\n          }\n          else if (shots > 3 && sfx_silenced_auto) {\n            AudioHelper.play({ src: `${sfx_silenced_auto}` }, true);\n          }\n          else {\n            AudioHelper.play({ src: `${sfx_silenced}` }, true);\n          }\n        }\n        else {\n          if (shots === 2) {\n            AudioHelper.play({ src: `${sfx_shot}` }, true);\n            await wait(`${sfxDelay}`);\n            AudioHelper.play({ src: `${sfx_shot}` }, true);\n          }\n          else if (shots === 3) {\n            //console.log(\"I AM HERE!\");\n            AudioHelper.play({ src: `${sfx_shot}` }, true);\n            await wait(`${sfxDelay}`);\n            AudioHelper.play({ src: `${sfx_shot}` }, true);\n            await wait(`${sfxDelay}`);\n            AudioHelper.play({ src: `${sfx_shot}` }, true);\n          }\n          else if (shots > 3 && sfx_shot_auto) {\n            AudioHelper.play({ src: `${sfx_shot_auto}` }, true);\n          }\n          else {\n            AudioHelper.play({ src: `${sfx_shot}` }, true);\n          }\n        }\n      }\n    }\n    // Check if enough bullets are in the weapon to fire the given amount of shots if this is not a consumable weapon and does require loading action.\n    else if (currentCharges < shots && item_weapon.data.data.autoReload === false) {\n      ui.notifications.error(\"You have insufficient ammunition.\")\n      if (sfx_empty && currentCharges === 0) {\n        AudioHelper.play({ src: `${sfx_empty}` }, true);\n      }\n      return;\n    }\n    else {\n      const updates = [\n        { _id: item_weapon.id, \"data.currentShots\": `${newCharges}` },\n      ];\n      // Updating the Weapon\n      actor.updateOwnedItem(updates);\n      // Creating the Chat message\n      if (!currentAmmo) {\n        ChatMessage.create({\n          speaker: {\n            alias: token.name\n          },\n          content: `<img src=\"${weaponIMG}\" alt=\"\" width=\"25\" height=\"25\" /> ${token.name} fires <b>${shots} round(s)</b> from a ${item_weapon.name} and has <b>${newCharges} left</b>.`\n        })\n      } else {\n        ChatMessage.create({\n          speaker: {\n            alias: token.name\n          },\n          content: `<img src=\"${weaponIMG}\" alt=\"\" width=\"25\" height=\"25\" /> ${token.name} fires <b>${shots} ${currentAmmo} round(s)</b> from a ${item_weapon.name} and has <b>${newCharges} left</b>.`\n        })\n      }\n      // Play sound effects\n      if (sil === true && sfx_silenced) {\n        if (shots === 2) {\n          AudioHelper.play({ src: `${sfx_silenced}` }, true);\n          await wait(`${sfxDelay}`);\n          AudioHelper.play({ src: `${sfx_silenced}` }, true);\n        }\n        else if (shots === 3) {\n          //console.log(\"I AM HERE!\");\n          AudioHelper.play({ src: `${sfx_silenced}` }, true);\n          await wait(`${sfxDelay}`);\n          AudioHelper.play({ src: `${sfx_silenced}` }, true);\n          await wait(`${sfxDelay}`);\n          AudioHelper.play({ src: `${sfx_silenced}` }, true);\n        }\n        else if (shots > 3 && sfx_silenced_auto) {\n          AudioHelper.play({ src: `${sfx_silenced_auto}` }, true);\n        }\n        else {\n          AudioHelper.play({ src: `${sfx_silenced}` }, true);\n        }\n      }\n      else {\n        if (shots === 2) {\n          AudioHelper.play({ src: `${sfx_shot}` }, true);\n          await wait(`${sfxDelay}`);\n          AudioHelper.play({ src: `${sfx_shot}` }, true);\n        }\n        else if (shots === 3) {\n          //console.log(\"I AM HERE!\");\n          AudioHelper.play({ src: `${sfx_shot}` }, true);\n          await wait(`${sfxDelay}`);\n          AudioHelper.play({ src: `${sfx_shot}` }, true);\n          await wait(`${sfxDelay}`);\n          AudioHelper.play({ src: `${sfx_shot}` }, true);\n        }\n        else if (shots > 3 && sfx_shot_auto) {\n          AudioHelper.play({ src: `${sfx_shot_auto}` }, true);\n        }\n        else {\n          AudioHelper.play({ src: `${sfx_shot}` }, true);\n        }\n      }\n    }\n\n    // console.log(\"Shoot | \", shots, weapon, ammo, sil, item_weapon);\n  }\n  function reload(html) {\n    let [shots, weapon, ammo, singleReload] = getValues(html);\n    // If no ammo left throw an error message.\n    if (!ammo) {\n      return ui.notifications.error(\"You have no ammo left to reload this weapon.\");\n    }\n    let item_weapon = actor.items.get(weapon);\n    // Do not allow consumable weapons to be reloaded\n    if (item_weapon.data.data.additionalStats.isConsumable && item_weapon.data.data.additionalStats.isConsumable.value === true) {\n      return ui.notifications.error(\"You cannot reload consumable weapons, please use Shooting instead.\");\n    }\n    let item_ammo = actor.items.getName(`${ammo}`);\n    //console.log(weapon, item_weapon, ammo, item_ammo);\n    const oldAmmo = item_weapon.data.data.additionalStats.loadedAmmo.value;\n    let item_oldAmmo;\n    if (!oldAmmo) {\n      item_oldAmmo = item_ammo;\n    }\n    else {\n      item_oldAmmo = actor.items.getName(`${oldAmmo}`);\n    }\n    // We suspect that the ammo to reload is the same as the previously loaded one. If not chgType will tell the code to swap the ammo.\n    let chgType = false;\n    if (item_oldAmmo != item_ammo) {\n      chgType = true;\n    }\n    // Getting the sfx from the selected weapon\n    let sfx_reload/* = stuff*/;\n    if (item_weapon.data.data.additionalStats.sfx) {\n      let sfx = item_weapon.data.data.additionalStats.sfx.value.split(`|`);\n      sfx_reload = sfx[0];\n    }\n    // Getting images from items\n    const weaponIMG = item_weapon.data.img;\n    const ammoIMG = item_ammo.data.img;\n\n    // Getting current numbers\n    const currentCharges = parseInt(item_weapon.data.data.currentShots);\n    const maxCharges = parseInt(item_weapon.data.data.shots);\n    const requiredCharges = parseInt(item_weapon.data.data.shots - currentCharges);\n    const availableAmmo = parseInt(item_ammo.data.data.quantity);\n    const oldAmmoQuantity = parseInt(item_oldAmmo.data.data.quantity);\n    // Variables for recharging procedure\n    let amountToRecharge;\n    let newCharges;\n    let newAmmo;\n    let oldAmmoRefill;\n    // Checking if the Ammo is a charge pack. If not or additionalStat is not present ignore it. Charge Packs can only refill if curr and max shots are equal.\n    if (item_ammo.data.data.additionalStats.isPack && item_ammo.data.data.additionalStats.isPack.value === true) {\n      // Charge Packs only use 1 Quantity to fully charge the weapon\n      amountToRecharge = parseInt(item_weapon.data.data.shots);\n      newCharges = amountToRecharge;\n      newAmmo = availableAmmo - 1;\n      //Refill old Charge Pack if it is still full (current and max shots are equal)\n      if (chgType === true && currentCharges === maxCharges) {\n        oldAmmoRefill = oldAmmoQuantity + 1;\n      }\n      else if (chgType === true && currentCharges != maxCharges) {\n        oldAmmoRefill = oldAmmoQuantity;\n      }\n    }\n    // Checking if user selected to change the ammo type. This is only relevant if not a Charge Pack, if it is, it's already handled above.\n    else if (chgType === true) {\n      // When changing Ammo type, remaining shots should not become the new Ammo Type.\n      amountToRecharge = parseInt(item_weapon.data.data.shots);\n      //Change the amount to recharge to 1 if singleReload is checked.\n      if (singleReload === true) { amountToRecharge = 1; }\n      newCharges = amountToRecharge;\n      newAmmo = availableAmmo - amountToRecharge;\n      oldAmmoRefill = oldAmmoQuantity + currentCharges;\n    }\n    else {\n      // If the quantity of ammo is less than the amount required, use whatever is left.\n      amountToRecharge = Math.min(availableAmmo, requiredCharges);\n      //Change the amount to recharge to 1 if singleReload is checked.\n      if (singleReload === true) { amountToRecharge = 1; }\n      newCharges = currentCharges + amountToRecharge;\n      newAmmo = availableAmmo - amountToRecharge;\n    }\n    // Check if there is ammo left to reload.\n    if (availableAmmo < 1) {\n      ui.notifications.notify(\"You are out of ammunition.\")\n    }\n    else if (chgType === true) {\n      const updates = [\n        { _id: item_weapon.id, \"data.currentShots\": `${newCharges}`, \"data.additionalStats.loadedAmmo.value\": `${ammo}` },\n        { _id: item_ammo.id, \"data.quantity\": `${newAmmo}` },\n        { _id: item_oldAmmo.id, \"data.quantity\": `${oldAmmoRefill}` },\n      ];\n\n      actor.updateOwnedItem(updates);\n      ChatMessage.create({\n        speaker: {\n          alias: token.name\n        },\n        content: `<img src=\"${weaponIMG}\" alt=\"\" width=\"25\" height=\"25\" /><img src=\"${ammoIMG}\" alt=\"\" width=\"25\" height=\"25\" /> ${token.name} reloads his/her ${item_weapon.name} with ${item_ammo.name}.`\n      })\n      if (sfx_reload) {\n        AudioHelper.play({ src: `${sfx_reload}` }, true)\n      }\n    }\n    else {\n      const updates = [\n        { _id: item_weapon.id, \"data.currentShots\": `${newCharges}`, \"data.additionalStats.loadedAmmo.value\": `${ammo}` },\n        { _id: item_ammo.id, \"data.quantity\": `${newAmmo}` },\n      ];\n\n      actor.updateOwnedItem(updates);\n      ChatMessage.create({\n        speaker: {\n          alias: token.name\n        },\n        content: `<img src=\"${weaponIMG}\" alt=\"\" width=\"25\" height=\"25\" /><img src=\"${ammoIMG}\" alt=\"\" width=\"25\" height=\"25\" /> ${token.name} reloads his/her ${item_weapon.name} with ${item_ammo.name}.`\n      })\n      if (sfx_reload) {\n        AudioHelper.play({ src: `${sfx_reload}` }, true)\n      }\n    }\n\n    // Ammo with no more bullets left are NOT deleted because that could cause issues when trying to change the ammo.\n  }\n  function getValues(html) {\n    return [\n      html.find(`#shots`)[0].valueAsNumber,\n      html.find(`#weapon`)[0].value,\n      html.find(`#ammo`)[0].value,\n      html.find(`#singleReload`)[0].checked,\n    ];\n  }\n  // V. 3.0.0 By SalieriC#8263. Dialogue Framework: Kekilla#7036\n}\n\nweaponDialog();","author":"wpWSO3unowg8siJN","img":"icons/weapons/crossbows/crossbow-white.webp","actorIds":[]}
{"_id":"49TiCaAgArpHsAhz","name":"SWIM: Ammo usage","permission":{"default":0,"wpWSO3unowg8siJN":3},"type":"script","flags":{"combat-utility-belt":{"macroTrigger":""},"furnace":{"runAsGM":false},"core":{"sourceId":"Macro.mMb87BLxl6JfQXQ1"}},"scope":"global","command":"checkWeapon();\n\nasync function wait(ms) {\n    return new Promise(resolve => {\n        setTimeout(resolve, ms);\n    });\n}\n\nasync function checkWeapon() {\n    //Don't execute the macro on a reroll by checking if the old_rolls is empty:\n    if (message.data.flags['betterrolls-swade2'].render_data.trait_roll.old_rolls.length >= 1) { return; }\n    //Check whether or not the weapon is suitable for the shooting macro\n    if (\n        (item.type === \"weapon\" &&\n            //i.data.data.range !== \"0\" && i.data.data.range !== \"\" &&\n            item.data.data.ammo.trim() !== \"\" &&\n            item.data.data.quantity > 0) ||\n        (item.type === \"weapon\" &&\n            //i.data.data.range !== \"0\" && i.data.data.range !== \"\" &&\n            item.data.data.additionalStats.isConsumable &&\n            item.data.data.additionalStats.isConsumable.value === true /*&&\n            //Ignore quantity to get a notification below for BR2 integration.\n            item.data.data.quantity > 0*/)\n    ) { shoot(); }\n    else { return; }\n}\n\nasync function shoot() {\n    //let [shots, weapon, ammo, sil] = getValues(html);\n    let item_weapon = item;\n    //Stop if the item is not a weapon:\n    if (item_weapon.type != \"weapon\") { return; }\n    //Get ammo loaded in the weapon and amount of shots provided by BR2 as well as a silenced state:\n    let item_ammo;\n    if (item_weapon.data.data.additionalStats.loadedAmmo) {\n        let loaded_ammo = item_weapon.data.data.additionalStats.loadedAmmo.value;\n        item_ammo = actor.items.getName(`${loaded_ammo}`);\n    }\n    //Setting the amount of shots based on RoF:\n    let traitDice = message.data.flags['betterrolls-swade2'].render_data.trait_roll.dice;\n    //console.log(traitDice);\n    //console.log(message.data.flags['betterrolls-swade2'].render_data);\n    let rate_of_fire = traitDice.length;\n    if (actor.data.data.wildcard === true) { rate_of_fire = rate_of_fire - 1; }\n    //console.log(rate_of_fire);\n    let shots = message.data.flags['betterrolls-swade2'].render_data.used_shots;\n    //failsafe to guss amount of shots in case BR2 return zero or undefined:\n    if (shots === 0 || !shots) {\n      if (rate_of_fire === 1) { shots = 1; }\n      if (rate_of_fire === 2) { shots = 5; }\n      if (rate_of_fire === 3) { shots = 10; }\n      if (rate_of_fire === 4) { shots = 20; }\n      if (rate_of_fire === 5) { shots = 40; }\n      if (rate_of_fire === 6) { shots = 50; }\n    }\n\n    let sil = false;\n    if (item_weapon.data.data.additionalStats.silenced && item_weapon.data.data.additionalStats.silenced.value === true) {\n        sil = true;\n    }\n    // Getting sfxDelay from game settings\n    let sfxDelay = game.settings.get(\n        'swim', 'sfxDelay');\n    // Getting the sfx from the weapon provided by BR2:\n    let sfx_shot;\n    let sfx_silenced;\n    let sfx_shot_auto;\n    let sfx_silenced_auto;\n    let sfx_empty;\n    if (item_weapon.data.data.additionalStats.sfx) {\n        let sfx = item_weapon.data.data.additionalStats.sfx.value.split(`|`);\n        sfx_shot = sfx[1];\n        sfx_silenced = sfx[3];\n        sfx_shot_auto = sfx[2];\n        sfx_silenced_auto = sfx[4];\n        sfx_empty = sfx[5];\n    }\n    // Getting Weapon and loaded ammo\n    const weaponIMG = item_weapon.data.img;\n    let currentAmmo\n    if (item_weapon.data.data.additionalStats.loadedAmmo) {\n        currentAmmo = item_weapon.data.data.additionalStats.loadedAmmo.value;\n    }\n\n    // Calculating shots to expend\n    const currentCharges = parseInt(item_weapon.data.data.currentShots);\n    const newCharges = currentCharges - shots;\n    if (item_weapon.data.data.additionalStats.isConsumable && item_weapon.data.data.additionalStats.isConsumable.value === true) {\n        //Get Skill from BR2. This returns as \"Skill dx\" so we need to filter that later...\n        let usedSkill = message.data.flags['betterrolls-swade2'].render_data.skill_title;\n        //We assume that all consumable weapons use \"Athletics\", \"Athletics (Throwing)\", \"Athletics (Explosives)\" or \"Throwing\" and only proceed if one of these skills was used. This is where we filter with .includes().\n        if (usedSkill.includes(\"Athletics\") === false &&\n        usedSkill.includes(\"Athletics (Throwing)\") === false &&\n        usedSkill.includes(\"Athletics (Explosives)\") === false &&\n        usedSkill.includes(\"Throwing\") === false) { return; }\n        const currentQuantity = parseInt(item_weapon.data.data.quantity);\n        if (currentQuantity <= 0) {\n            return ui.notifications.error(`You don't have a ${item_weapon.name} left.`);\n        }\n        const newQuantity = currentQuantity - shots;\n        const updates = [\n            { _id: item_weapon.id, \"data.quantity\": `${newQuantity}` },\n        ];\n        // Updating the consumable weapon\n        await actor.updateOwnedItem(updates);\n        // Deleting the consumable weapon if it was the last (disabled because it breaks rerolls in BR2)\n        /*if (newQuantity <= 0) {\n            item_weapon.delete();\n        }*/\n        // Creating the Chat message\n        ChatMessage.create({\n            speaker: {\n                alias: actor.name\n            },\n            content: `<img src=\"${weaponIMG}\" alt=\"\" width=\"25\" height=\"25\" /> ${actor.name} uses ${shots} ${item_weapon.name}(s) and has ${newQuantity} left.`\n        })\n        // Play sound effects\n        if (sfx_shot) {\n            AudioHelper.play({ src: `${sfx_shot}` }, true);\n        }\n    }\n    //Stuff for weapons with \"doesn't require reload action\" checked:\n    else if (item_weapon.data.data.autoReload === true) {\n        //Throw error if no ammo is left.\n        if (item_ammo && item_ammo.data.data.quantity <= 0) { return ui.notifications.error(`You don't have a ${item_weapon.name} left.`); }\n        //Failsafe in case no ammo is provided.\n        else if (!item_ammo) { return ui.notifications.error(`Please define your desired Ammo in \"Loaded Ammo\" first.`); }\n        else {\n            //Setting new constants to overwrite the old ones\n            const currentCharges = parseInt(item_ammo.data.data.quantity);\n            const newCharges = currentCharges - shots;\n            //Setting up the updates\n            const updates = [\n                { _id: item_ammo.id, \"data.quantity\": `${newCharges}` },\n            ];\n            // Updating the Weapon\n            actor.updateOwnedItem(updates);\n            //Creating the chat message\n            ChatMessage.create({\n                speaker: {\n                    alias: actor.name\n                },\n                content: `<img src=\"${weaponIMG}\" alt=\"\" width=\"25\" height=\"25\" /> ${actor.name} fires <b>${shots} ${currentAmmo} round(s)</b> from a ${item_weapon.name} and has <b>${newCharges} left</b>.`\n            })\n            //Playing the SFX\n            // Play sound effects\n            if (sil === true && sfx_silenced) {\n                if (shots === 2) {\n                  AudioHelper.play({ src: `${sfx_silenced}` }, true);\n                  await wait(`${sfxDelay}`);\n                  AudioHelper.play({ src: `${sfx_silenced}` }, true);\n                }\n                else if (shots === 3) {\n                  //console.log(\"I AM HERE!\");\n                  AudioHelper.play({ src: `${sfx_silenced}` }, true);\n                  await wait(`${sfxDelay}`);\n                  AudioHelper.play({ src: `${sfx_silenced}` }, true);\n                  await wait(`${sfxDelay}`);\n                  AudioHelper.play({ src: `${sfx_silenced}` }, true);\n                }\n                else if (shots > 3 && sfx_silenced_auto) {\n                    AudioHelper.play({ src: `${sfx_silenced_auto}` }, true);\n                }\n                else {\n                    AudioHelper.play({ src: `${sfx_silenced}` }, true);\n                }\n            }\n            else {\n              if (shots === 2) {\n                AudioHelper.play({ src: `${sfx_shot}` }, true);\n                await wait(`${sfxDelay}`);\n                AudioHelper.play({ src: `${sfx_shot}` }, true);\n              }\n              else if (shots === 3) {\n                //console.log(\"I AM HERE!\");\n                AudioHelper.play({ src: `${sfx_shot}` }, true);\n                await wait(`${sfxDelay}`);\n                AudioHelper.play({ src: `${sfx_shot}` }, true);\n                await wait(`${sfxDelay}`);\n                AudioHelper.play({ src: `${sfx_shot}` }, true);\n              }\n              else if (shots > 3 && sfx_shot_auto) {\n                    AudioHelper.play({ src: `${sfx_shot_auto}` }, true);\n                }\n                else {\n                    AudioHelper.play({ src: `${sfx_shot}` }, true);\n                }\n            }\n        }\n    }\n    // Check if enough bullets are in the weapon to fire the given amount of shots if this is not a consumable weapon and does require loading action.\n    else if (currentCharges < shots && item_weapon.data.data.autoReload === false) {\n        ui.notifications.error(\"You have insufficient ammunition.\");\n        if (sfx_empty && currentCharges === 0) {\n            AudioHelper.play({ src: `${sfx_empty}` }, true);\n        }\n        return;\n    }\n    else {\n        const updates = [\n            { _id: item_weapon.id, \"data.currentShots\": `${newCharges}` },\n        ];\n        // Updating the Weapon\n        actor.updateOwnedItem(updates);\n        // Creating the Chat message\n        if (!currentAmmo) {\n            ChatMessage.create({\n                speaker: {\n                    alias: actor.name\n                },\n                content: `<img src=\"${weaponIMG}\" alt=\"\" width=\"25\" height=\"25\" /> ${actor.name} fires <b>${shots} round(s)</b> from a ${item_weapon.name} and has <b>${newCharges} left</b>.`\n            })\n        } else {\n            ChatMessage.create({\n                speaker: {\n                    alias: actor.name\n                },\n                content: `<img src=\"${weaponIMG}\" alt=\"\" width=\"25\" height=\"25\" /> ${actor.name} fires <b>${shots} ${currentAmmo} round(s)</b> from a ${item_weapon.name} and has <b>${newCharges} left</b>.`\n            })\n        }\n        // Play sound effects\n        if (sil === true && sfx_silenced) {\n          if (shots === 2) {\n            AudioHelper.play({ src: `${sfx_silenced}` }, true);\n            await wait(`${sfxDelay}`);\n            AudioHelper.play({ src: `${sfx_silenced}` }, true);\n          }\n          else if (shots === 3) {\n            //console.log(\"I AM HERE!\");\n            AudioHelper.play({ src: `${sfx_silenced}` }, true);\n            await wait(`${sfxDelay}`);\n            AudioHelper.play({ src: `${sfx_silenced}` }, true);\n            await wait(`${sfxDelay}`);\n            AudioHelper.play({ src: `${sfx_silenced}` }, true);\n          }\n          else if (shots > 3 && sfx_silenced_auto) {\n                AudioHelper.play({ src: `${sfx_silenced_auto}` }, true);\n            }\n            else {\n                AudioHelper.play({ src: `${sfx_silenced}` }, true);\n            }\n        }\n        else {\n          if (shots === 2) {\n            AudioHelper.play({ src: `${sfx_shot}` }, true);\n            await wait(`${sfxDelay}`);\n            AudioHelper.play({ src: `${sfx_sshot}` }, true);\n          }\n          else if (shots === 3) {\n            //console.log(\"I AM HERE!\");\n            AudioHelper.play({ src: `${sfx_shot}` }, true);\n            await wait(`${sfxDelay}`);\n            AudioHelper.play({ src: `${sfx_shot}` }, true);\n            await wait(`${sfxDelay}`);\n            AudioHelper.play({ src: `${sfx_shot}` }, true);\n          }\n          else if (shots > 3 && sfx_shot_auto) {\n                AudioHelper.play({ src: `${sfx_shot_auto}` }, true);\n            }\n            else {\n                AudioHelper.play({ src: `${sfx_shot}` }, true);\n            }\n        }\n    }\n    //V. 3.0.0 by SalieriC#8263 with help from javierrivera#4813.\n}","author":"wpWSO3unowg8siJN","img":"icons/weapons/crossbows/crossbow-long-brown.webp","actorIds":[]}
